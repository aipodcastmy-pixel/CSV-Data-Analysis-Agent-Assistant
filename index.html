<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>CSV Data Analysis Agent</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              'brand-primary': '#2563eb', // A slightly brighter blue for light mode
              'brand-secondary': '#3b82f6',
            },
            animation: {
                'loading-shimmer': 'loading-shimmer 2s infinite linear',
            },
            keyframes: {
                'loading-shimmer': {
                    '0%': { 'background-position': '-200% 0' },
                    '100%': { 'background-position': '200% 0' },
                }
            }
          },
        },
      }
    </script>
    <!-- React -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <!-- Babel for JSX (dev-only, but needed for this setup) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Chart.js for charts -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.2/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
    <!-- Papaparse for CSV parsing -->
    <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>
    <!-- IDB for IndexedDB -->
    <script src="https://unpkg.com/idb@7.1.1/build/umd.js"></script>
    <!-- html-to-image for exporting -->
    <script src="https://unpkg.com/html-to-image@1.11.11/dist/html-to-image.js"></script>
  <script type="importmap">
{
  "imports": {
    "react/": "https://aistudiocdn.com/react@^19.2.0/",
    "react": "https://aistudiocdn.com/react@^19.2.0",
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.0/",
    "@google/genai": "https://aistudiocdn.com/@google/genai@^1.28.0",
    "idb": "https://aistudiocdn.com/idb@^8.0.3"
  }
}
</script>
</head>
  <body class="bg-slate-50 text-slate-800">
    <div id="root"></div>
    <script type="text/babel" data-type="module">
// External library imports are handled by the importmap
import { GoogleGenAI, Type } from "@google/genai";
import { pipeline, env } from 'https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.1';

// React hooks for convenience
const { useState, useEffect, useCallback, useRef, useMemo, forwardRef, useImperativeHandle } = React;

// --- START OF INLINED CODE ---

// =================================================================================
// from utils/exportUtils.ts
// =================================================================================
const exportToPng = async (element, title) => {
  try {
    const dataUrl = await htmlToImage.toPng(element, { 
      backgroundColor: '#ffffff', // Use a white background for light theme
      pixelRatio: 2,
    });
    const link = document.createElement('a');
    link.download = `${title.replace(/ /g, '_')}.png`;
    link.href = dataUrl;
    link.click();
  } catch (error) {
    console.error('Error exporting to PNG:', error);
  }
};

const exportToCsv = (data, title) => {
  try {
    const csv = Papa.unparse(data);
    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.setAttribute('download', `${title.replace(/ /g, '_')}.csv`);
    link.click();
  } catch (error) {
    console.error('Error exporting to CSV:', error);
  }
};

const exportToHtml = async (element, title, data, summary) => {
   try {
    const chartCanvas = element.querySelector('canvas');
    if (!chartCanvas) {
        throw new Error("Chart canvas not found for export.");
    }
    const chartImage = chartCanvas.toDataURL('image/png');

    const dataTableHtml = `
      <table border="1" style="border-collapse: collapse; width: 100%; font-family: sans-serif; color: #333;">
        <thead>
          <tr style="background-color: #f2f2f2;">
            ${Object.keys(data[0] || {}).map(key => `<th style="padding: 8px;">${key}</th>`).join('')}
          </tr>
        </thead>
        <tbody>
          ${data.map(row => `
            <tr>
              ${Object.values(row).map(val => `<td style="padding: 8px;">${val}</td>`).join('')}
            </tr>
          `).join('')}
        </tbody>
      </table>
    `;
    const summaryHtml = summary.replace(/\n/g, '<br>').replace('---', '<hr>');

    const htmlContent = `
      <!DOCTYPE html>
      <html lang="en">
        <head>
          <meta charset="UTF-8">
          <title>${title}</title>
          <style> body { font-family: sans-serif; line-height: 1.6; padding: 20px; } h1, h2 { color: #111827; } .card { border: 1px solid #ddd; padding: 20px; border-radius: 8px; margin-bottom: 20px; } </style>
        </head>
        <body>
          <h1>Analysis Report: ${title}</h1>
          <div class="card">
            <h2>Chart</h2>
            <img src="${chartImage}" alt="Chart for ${title}" style="max-width: 100%; border: 1px solid #ddd; border-radius: 4px;">
          </div>
          <div class="card">
            <h2>AI Summary</h2>
            <p>${summaryHtml}</p>
          </div>
          <div class="card">
            <h2>Data</h2>
            ${dataTableHtml}
          </div>
          <p style="font-size: 0.8em; color: #888;">Generated by CSV Data Analysis Agent on ${new Date().toLocaleString()}</p>
        </body>
      </html>
    `;
    
    const blob = new Blob([htmlContent], { type: 'text/html;charset=utf-8;' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.setAttribute('download', `Report_${title.replace(/ /g, '_')}.html`);
    link.click();
  } catch (error) {
    console.error('Error exporting to HTML:', error);
  }
};

// =================================================================================
// from utils/dataProcessor.ts
// =================================================================================
const sanitizeValue = (value) => {
    if (typeof value === 'string' && value.startsWith('=')) {
        return `'${value}`;
    }
    return value;
};

const robustParseFloat = (value) => {
    if (value === null || value === undefined) return null;

    let s = String(value).trim();
    if (s === '') return null;

    let isNegative = false;
    if (s.startsWith('(') && s.endsWith(')')) {
        s = s.substring(1, s.length - 1);
        isNegative = true;
    }
    
    s = s.replace(/[$\s€£¥%]/g, '');

    const lastComma = s.lastIndexOf(',');
    const lastDot = s.lastIndexOf('.');
    
    if (lastComma > lastDot) {
        s = s.replace(/\./g, '').replace(',', '.');
    } else {
        s = s.replace(/,/g, '');
    }

    const num = parseFloat(s);

    if (isNaN(num)) {
        return null;
    }

    return isNegative ? -num : num;
};

const looksLikeDate = (value) => {
    if (typeof value !== 'string' || !value) return false;
    return !isNaN(new Date(value).getTime()) && /[0-9]{1,4}[-/][0-9]{1,2}[-/][0-9]{1,4}/.test(value);
};

const QUARTER_REGEX = /^Q([1-4])(?:\s*\/?\s*('?\d{2,4}))?$/i; 
const MONTHS = {
    'january': 1, 'jan': 1, 'february': 2, 'feb': 2, 'march': 3, 'mar': 3,
    'april': 4, 'apr': 4, 'may': 5, 'june': 6, 'jun': 6, 'july': 7, 'jul': 7,
    'august': 8, 'aug': 8, 'september': 9, 'sep': 9, 'october': 10, 'oct': 10,
    'november': 11, 'nov': 11, 'december': 12, 'dec': 12
};
const DAYS = {
    'monday': 1, 'mon': 1, 'tuesday': 2, 'tue': 2, 'wednesday': 3, 'wed': 3,
    'thursday': 4, 'thu': 4, 'friday': 5, 'fri': 5, 'saturday': 6, 'sat': 6,
    'sunday': 7, 'sun': 7
};

const getChronologicalSortValue = (value, sorter) => {
    const lowerValue = String(value).toLowerCase().trim();
    switch (sorter) {
        case 'quarter':
            const match = lowerValue.match(QUARTER_REGEX);
            if (match) {
                const quarter = parseInt(match[1], 10);
                let year = 0;
                if (match[2]) {
                    const yearStr = match[2].replace("'", '');
                    year = parseInt(yearStr, 10);
                    if (yearStr.length === 2) {
                        year += (year > 50 ? 1900 : 2000);
                    }
                }
                return year * 10 + quarter;
            }
            return Infinity;
        case 'month':
            return MONTHS[lowerValue] || Infinity;
        case 'day':
            return DAYS[lowerValue] || Infinity;
    }
    return Infinity;
};

const tryChronologicalSort = (data, key) => {
    if (data.length < 2) return data;
    const sampleValues = data.slice(0, 10).map(r => String(r[key]).toLowerCase().trim());
    let sorter = null;
    const quarterMatches = sampleValues.filter(v => QUARTER_REGEX.test(v)).length;
    const monthMatches = sampleValues.filter(v => MONTHS[v] !== undefined).length;
    const dayMatches = sampleValues.filter(v => DAYS[v] !== undefined).length;
    const dateMatches = sampleValues.filter(looksLikeDate).length;

    if (quarterMatches / sampleValues.length >= 0.5) sorter = 'quarter';
    else if (monthMatches / sampleValues.length >= 0.5) sorter = 'month';
    else if (dayMatches / sampleValues.length >= 0.5) sorter = 'day';
    else if (dateMatches / sampleValues.length >= 0.5) {
        return [...data].sort((a, b) => new Date(String(a[key])).getTime() - new Date(String(b[key])).getTime());
    }

    if (sorter) {
        return [...data].sort((a, b) => {
            const valA = getChronologicalSortValue(String(a[key]), sorter);
            const valB = getChronologicalSortValue(String(b[key]), sorter);
            return valA - valB;
        });
    }
    return null;
};

const applyTopNWithOthers = (data, groupByKey, valueKey, topN) => {
    if (data.length <= topN) {
        return data;
    }
    const sortedData = [...data].sort((a, b) => (Number(b[valueKey]) || 0) - (Number(a[valueKey]) || 0));
    const topData = sortedData.slice(0, topN - 1);
    const otherData = sortedData.slice(topN - 1);

    if (otherData.length > 0) {
        const otherSum = otherData.reduce((acc, row) => acc + (Number(row[valueKey]) || 0), 0);
        const othersRow = { [groupByKey]: 'Others', [valueKey]: otherSum };
        return [...topData, othersRow];
    }
    return topData;
};

const processCsv = (file) => {
    return new Promise((resolve, reject) => {
        Papa.parse(file, {
            header: false,
            skipEmptyLines: true,
            worker: true,
            complete: (results) => {
                if (results.data.length === 0) {
                    resolve({ fileName: file.name, data: [] });
                    return;
                }
                const maxCols = results.data.reduce((max, row) => Math.max(max, row.length), 0);
                const genericHeaders = Array.from({ length: maxCols }, (_, i) => `column_${i + 1}`);
                const objectData = results.data.map(rowArray => {
                    const newRow = {};
                    genericHeaders.forEach((header, index) => {
                        const value = rowArray[index] !== undefined ? rowArray[index] : '';
                        newRow[header] = sanitizeValue(String(value));
                    });
                    return newRow;
                });
                resolve({ fileName: file.name, data: objectData });
            },
            error: (error) => reject(error),
        });
    });
};

const profileData = (data) => {
    if (!data || data.length === 0) return [];
    const headers = Object.keys(data[0]);
    const profiles = [];

    for (const header of headers) {
        let isNumerical = true;
        const values = data.map(row => row[header]);
        let numericCount = 0;

        for (const value of values) {
            const parsedNum = robustParseFloat(value);
            if (value !== null && String(value).trim() !== '') {
                if (parsedNum === null) {
                    isNumerical = false;
                    break;
                }
                numericCount++;
            }
        }

        if (isNumerical && numericCount > 0) {
            const numericValues = values.map(robustParseFloat).filter(v => v !== null);
            profiles.push({
                name: header,
                type: 'numerical',
                valueRange: [Math.min(...numericValues), Math.max(...numericValues)],
                missingPercentage: (1 - (numericValues.length / data.length)) * 100,
            });
        } else {
            const uniqueValues = new Set(values.map(String));
            profiles.push({
                name: header,
                type: 'categorical',
                uniqueValues: uniqueValues.size,
                missingPercentage: (values.filter(v => v === null || String(v).trim() === '').length / data.length) * 100
            });
        }
    }
    return profiles;
};

const splitNumericString = (input) => {
    if (!input) return [];
    const parsableString = String(input).replace(/,(?=-?\d)/g, '|');
    return parsableString.split('|');
};

const executeJavaScriptDataTransform = (data, jsFunctionBody) => {
    try {
        const _util = { parseNumber: robustParseFloat, splitNumericString: splitNumericString };
        const transformFunction = new Function('data', '_util', jsFunctionBody);
        const result = transformFunction(data, _util);

        if (!Array.isArray(result)) {
            console.error("AI-generated transform function returned a non-array value.", { returnedValue: result, generatedCode: jsFunctionBody });
            throw new Error('AI-generated transform function did not return an array.');
        }
        if (result.length > 0 && typeof result[0] !== 'object') {
            throw new Error('AI-generated transform function did not return an array of objects.');
        }
        return result;
    } catch (error) {
        console.error("Error executing AI-generated JavaScript:", error);
        throw new Error(`AI-generated data transformation failed: ${error instanceof Error ? error.message : String(error)}`);
    }
};

const executePlan = (data, plan) => {
    if (plan.chartType === 'scatter') {
        const { xValueColumn, yValueColumn } = plan;
        if (!xValueColumn || !yValueColumn) {
            throw new Error("Scatter plot plan is missing xValueColumn or yValueColumn.");
        }
        return data.data
            .map(row => ({
                [xValueColumn]: robustParseFloat(row[xValueColumn]),
                [yValueColumn]: robustParseFloat(row[yValueColumn]),
            }))
            .filter(p => p[xValueColumn] !== null && p[yValueColumn] !== null);
    }

    const { groupByColumn, aggregation } = plan;
    let { valueColumn } = plan;
    if (!groupByColumn || !aggregation) {
        throw new Error("Analysis plan is missing groupByColumn or aggregation type for non-scatter chart.");
    }

    const groups = {};
    data.data.forEach(row => {
        const groupKey = String(row[groupByColumn]);
        if (groupKey === 'undefined' || groupKey === 'null') return;
        if (!groups[groupKey]) {
            groups[groupKey] = [];
        }
        if (valueColumn) {
            const value = robustParseFloat(row[valueColumn]);
            if (value !== null) {
                groups[groupKey].push(value);
            }
        } else if (aggregation === 'count') {
            groups[groupKey].push(1);
        }
    });

    const aggregatedResult = [];
    for (const key in groups) {
        const values = groups[key];
        let resultValue;
        switch (aggregation) {
            case 'sum':
                resultValue = values.reduce((acc, val) => acc + val, 0);
                break;
            case 'count':
                resultValue = values.length;
                break;
            case 'avg':
                const sum = values.reduce((acc, val) => acc + val, 0);
                resultValue = values.length > 0 ? sum / values.length : 0;
                break;
            default:
                throw new Error(`Unsupported aggregation type: ${aggregation}`);
        }
        const finalValueColumn = valueColumn || 'count';
        aggregatedResult.push({ [groupByColumn]: key, [finalValueColumn]: resultValue });
    }

    const chronologicallySorted = tryChronologicalSort(aggregatedResult, groupByColumn);
    if (chronologicallySorted) {
        return chronologicallySorted;
    } else {
        const finalValueColumn = valueColumn || 'count';
        return aggregatedResult.sort((a, b) => (Number(b[finalValueColumn]) || 0) - (Number(a[finalValueColumn]) || 0));
    }
};


// =================================================================================
// from storageService.ts
// =================================================================================
const { openDB } = idb;
const DB_NAME = 'csv-ai-assistant-db';
const REPORTS_STORE_NAME = 'reports';
const SETTINGS_KEY = 'csv-ai-assistant-settings';
const CURRENT_SESSION_KEY = 'current_session';

let dbPromise;
const getDb = () => {
  if (!dbPromise) {
    dbPromise = openDB(DB_NAME, 2, {
      upgrade(db, oldVersion) {
        if (oldVersion < 2) {
            if (!db.objectStoreNames.contains(REPORTS_STORE_NAME)) {
                const store = db.createObjectStore(REPORTS_STORE_NAME, { keyPath: 'id' });
                store.createIndex('updatedAt', 'updatedAt');
            }
        }
      },
    });
  }
  return dbPromise;
};

const saveReport = async (report) => {
  try {
    const db = await getDb();
    await db.put(REPORTS_STORE_NAME, report);
  } catch (error) {
    console.error('Failed to save report to IndexedDB:', error);
  }
};

const getReport = async (id) => {
  try {
    const db = await getDb();
    return await db.get(REPORTS_STORE_NAME, id);
  } catch (error) {
    console.error('Failed to get report from IndexedDB:', error);
    return undefined;
  }
};

const getReportsList = async () => {
    try {
        const db = await getDb();
        const allReports = await db.getAllFromIndex(REPORTS_STORE_NAME, 'updatedAt');
        return allReports
            .sort((a, b) => b.updatedAt.getTime() - a.updatedAt.getTime())
            .map(({ id, filename, createdAt, updatedAt }) => ({ id, filename, createdAt, updatedAt }));
    } catch (error) {
        console.error('Failed to get reports list from IndexedDB:', error);
        return [];
    }
}

const deleteReport = async (id) => {
    try {
        const db = await getDb();
        await db.delete(REPORTS_STORE_NAME, id);
    } catch (error) {
        console.error('Failed to delete report from IndexedDB:', error);
    }
};

const defaultSettings = {
    provider: 'google',
    geminiApiKey: '',
    openAIApiKey: '',
    model: 'gemini-2.5-pro',
    language: 'English'
};

const saveSettings = (settings) => {
    try {
        localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
    } catch (error) {
        console.error('Failed to save settings to localStorage:', error);
    }
};

const getSettings = () => {
    try {
        const settingsJson = localStorage.getItem(SETTINGS_KEY);
        if (settingsJson) {
            const savedSettings = JSON.parse(settingsJson);
            if (savedSettings.apiKey && !savedSettings.geminiApiKey) {
                savedSettings.geminiApiKey = savedSettings.apiKey;
                delete savedSettings.apiKey;
            }
            return { ...defaultSettings, ...savedSettings };
        }
    } catch (error) {
        console.error('Failed to get settings from localStorage:', error);
    }
    return defaultSettings;
};

// =================================================================================
// from services/vectorStore.ts
// =================================================================================
class VectorStore {
    constructor() {
        this.embedder = null;
        this.documents = [];
        this.isInitializing = false;
        this.isInitialized = false;
    }

    static getInstance() {
        if (!VectorStore.instance) {
            VectorStore.instance = new VectorStore();
        }
        return VectorStore.instance;
    }

    getIsInitialized() {
        return this.isInitialized;
    }

    async init(progressCallback) {
        if (this.isInitialized || this.isInitializing) return;

        try {
            this.isInitializing = true; 
            env.allowRemoteModels = true;
            
            progressCallback?.("Downloading AI memory model (~34MB)...");
            this.embedder = await pipeline('feature-extraction', 'Xenova/all-MiniLM-L6-v2', {
                progress_callback: (progress) => {
                     if (progress.status === 'progress' && progress.total > 0) {
                        const loaded = (progress.loaded / 1024 / 1024).toFixed(2);
                        const total = (progress.total / 1024 / 1024).toFixed(2);
                        progressCallback?.(`Downloading AI memory model: ${loaded}MB / ${total}MB`);
                     }
                }
            });
            progressCallback?.("AI memory model loaded.");
            this.isInitialized = true;
        } catch (error) {
            console.error("Failed to initialize vector store:", error);
            progressCallback?.(`Error loading AI memory model: ${error instanceof Error ? error.message : String(error)}`);
            this.isInitialized = false;
        } finally {
            this.isInitializing = false;
        }
    }
    
    rehydrate(documents) {
        this.documents = documents;
    }

    async addDocument(doc) {
        if (!this.embedder) {
            console.warn("Vector store not initialized. Skipping document add/update.");
            return;
        }

        try {
            const embedding = await this.embedder(doc.text, { pooling: 'mean', normalize: true });
            const newDoc = {
                ...doc,
                embedding: Array.from(embedding.data),
            };

            const existingDocIndex = this.documents.findIndex(d => d.id === doc.id);
            if (existingDocIndex > -1) {
                this.documents[existingDocIndex] = newDoc;
            } else {
                this.documents.push(newDoc);
            }
        } catch (error) {
            console.error(`Failed to create embedding for document ${doc.id}:`, error);
        }
    }

    deleteDocument(id) {
        const initialLength = this.documents.length;
        this.documents = this.documents.filter(doc => doc.id !== id);
        return this.documents.length < initialLength;
    }
    
    getDocumentCount() {
        return this.documents.length;
    }

    getDocuments() {
        return [...this.documents];
    }
    
    clear() {
        this.documents = [];
    }

    async search(queryText, k = 5) {
        if (!this.embedder || this.documents.length === 0) {
            return [];
        }

        try {
            const queryEmbedding = await this.embedder(queryText, { pooling: 'mean', normalize: true });
            const queryVector = Array.from(queryEmbedding.data);
            
            const results = this.documents.map(doc => {
                 const score = this.cosineSimilarity(queryVector, doc.embedding);
                 return { text: doc.text, score };
            });

            return results
                .filter(r => r.score > 0.5)
                .sort((a, b) => b.score - a.score)
                .slice(0, k);

        } catch (error) {
            console.error("Failed to perform vector search:", error);
            return [];
        }
    }

    cosineSimilarity(vecA, vecB) {
        let dotProduct = 0;
        let normA = 0;
        let normB = 0;
        for (let i = 0; i < vecA.length; i++) {
            dotProduct += vecA[i] * vecB[i];
            normA += vecA[i] * vecA[i];
            normB += vecB[i] * vecB[i];
        }
        if (normA === 0 || normB === 0) {
            return 0;
        }
        return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));
    }
}
const vectorStore = VectorStore.getInstance();

// =================================================================================
// from services/geminiService.ts
// =================================================================================
const withRetry = async (fn, retries = 2) => {
    let lastError;
    for (let i = 0; i < retries; i++) {
        try {
            return await fn();
        } catch (error) {
            lastError = error;
            console.warn(`API call failed, retrying... (${i + 1}/${retries})`, error);
            if (i < retries - 1) {
                await new Promise(res => setTimeout(res, 500));
            }
        }
    }
    throw lastError;
};


const planSchema = {
  type: Type.ARRAY,
  items: {
    type: Type.OBJECT,
    properties: {
      chartType: { type: Type.STRING, enum: ['bar', 'line', 'pie', 'doughnut', 'scatter'], description: 'Type of chart to generate.' },
      title: { type: Type.STRING, description: 'A concise title for the analysis.' },
      description: { type: Type.STRING, description: 'A brief explanation of what the analysis shows.' },
      aggregation: { type: Type.STRING, enum: ['sum', 'count', 'avg'], description: 'The aggregation function to apply. Omit for scatter plots.' },
      groupByColumn: { type: Type.STRING, description: 'The column to group data by (categorical). Omit for scatter plots.' },
      valueColumn: { type: Type.STRING, description: 'The column for aggregation (numerical). Not needed for "count".' },
      xValueColumn: { type: Type.STRING, description: 'The column for the X-axis of a scatter plot (numerical). Required for scatter plots.' },
      yValueColumn: { type: Type.STRING, description: 'The column for the Y-axis of a scatter plot (numerical). Required for scatter plots.' },
      defaultTopN: { type: Type.INTEGER, description: 'Optional. If the analysis has many categories, this suggests a default Top N view (e.g., 8).' },
      defaultHideOthers: { type: Type.BOOLEAN, description: 'Optional. If using defaultTopN, suggests whether to hide the "Others" category by default.' },
    },
    required: ['chartType', 'title', 'description'],
  },
};

const columnProfileSchema = {
    type: Type.OBJECT,
    properties: {
        name: { type: Type.STRING, description: "The column name." },
        type: { type: Type.STRING, enum: ['numerical', 'categorical', 'date', 'time', 'currency', 'percentage'], description: "The data type of the column. Identify specific types like 'date', 'currency', etc., where possible." },
    },
    required: ['name', 'type'],
};

const dataPreparationSchema = {
    type: Type.OBJECT,
    properties: {
        explanation: { type: Type.STRING, description: "A brief, user-facing explanation of the transformations that will be applied to the data (e.g., 'Removed 3 summary rows and reshaped the data from a cross-tab format')." },
        jsFunctionBody: {
            type: Type.STRING,
            description: "The body of a JavaScript function that takes two arguments `data` (an array of objects) and `_util` (a helper object) and returns the transformed array of objects. This code will be executed to clean and reshape the data. If no transformation is needed, this should be null."
        },
        outputColumns: {
            type: Type.ARRAY,
            description: "A list of column profiles describing the structure of the data AFTER the transformation. If no transformation is performed, this should be the same as the input column profiles.",
            items: columnProfileSchema,
        },
    },
    required: ['explanation', 'outputColumns']
};

const generateDataPreparationPlan = async (columns, sampleData, settings) => {
    let lastError;
    for(let i=0; i < 3; i++) {
        try {
            let jsonStr;
            if (settings.provider === 'openai') {
                if (!settings.openAIApiKey) return { explanation: "No transformation needed as API key is not set.", jsFunctionBody: null, outputColumns: columns };
                const systemPrompt = `You are an expert data engineer. Your task is to analyze a raw dataset and, if necessary, provide a JavaScript function to clean and reshape it into a tidy, analysis-ready format. CRITICALLY, you must also provide the schema of the NEW, transformed data with detailed data types.
A tidy format has: 1. Each variable as a column. 2. Each observation as a row.
You MUST respond with a single valid JSON object, and nothing else. The JSON object must adhere to the provided schema.`;
                const userPrompt = `Common problems to fix:
- **CRITICAL RULE on NUMBER PARSING**: This is the most common source of errors. To handle numbers that might be formatted as strings (e.g., "$1,234.56", "50%"), you are provided with a safe utility function: \`_util.parseNumber(value)\`.
    - **YOU MUST use \`_util.parseNumber(value)\` for ALL numeric conversions.**
    - **DO NOT use \`parseInt()\`, \`parseFloat()\`, or \`Number()\` directly.** The provided utility is guaranteed to handle various formats correctly.
- **CRITICAL RULE on SPLITTING NUMERIC STRINGS**: If you encounter a single string field that contains multiple comma-separated numbers (which themselves may contain commas as thousand separators, e.g., "1,234.50,5,678.00,-9,123.45"), you are provided a utility \`_util.splitNumericString(value)\` to correctly split the string into an array of number strings.
    - **YOU MUST use this utility for this specific case.**
    - **DO NOT use a simple \`string.split(',')\`**, as this will incorrectly break up numbers.
    - **Example**: To parse a field 'MonthlyValues' containing "1,500.00,2,000.00", your code should be: \`const values = _util.splitNumericString(row.MonthlyValues);\` This will correctly return \`['1,500.00', '2,000.00']\`.
- **Distinguishing Data from Summaries**: Your most critical task is to differentiate between valid data rows and non-data rows (like summaries or metadata).
    - A row is likely **valid data** if it has a value in its primary identifier column(s) (e.g., 'Account Code', 'Product ID') and in its metric columns.
    - **CRITICAL: Do not confuse hierarchical data with summary rows.** Look for patterns in identifier columns where one code is a prefix of another (e.g., '50' is a parent to '5010'). These hierarchical parent rows are **valid data** representing a higher level of aggregation and MUST be kept. Your role is to reshape the data, not to pre-summarize it by removing these levels.
    - A row is likely **non-data** and should be removed if it's explicitly a summary (e.g., contains 'Total', 'Subtotal' in a descriptive column) OR if it's metadata (e.g., the primary identifier column is empty but other columns contain text, like a section header).
- **Crosstab/Wide Format**: Unpivot data where column headers are values (e.g., years, regions).
- **Multi-header Rows**: Skip initial junk rows.
Dataset Columns (Initial Schema):
${JSON.stringify(columns, null, 2)}
Sample Data (up to 20 rows):
${JSON.stringify(sampleData, null, 2)}
${lastError ? `On the previous attempt, your generated code failed with this error: "${lastError.message}". Please analyze the error and the data, then provide a corrected response.` : ''}
Your task:
1.  **Analyze**: Look at the initial schema and sample data.
2.  **Plan Transformation**: Decide if cleaning or reshaping is needed. If you identify date or time columns as strings, your function should attempt to parse them into a standard format (e.g., 'YYYY-MM-DD' for dates).
3.  **Define Output Schema**: Determine the exact column names and types of the data AFTER your transformation. This is the MOST important step. Be as specific as possible with the types. Use 'categorical' for text labels, 'numerical' for general numbers, but you MUST identify and use the more specific types where they apply:
    - **'date'**: For columns containing dates (e.g., "2023-10-26", "10/26/2023").
    - **'time'**: For columns with time values (e.g., "14:30:00").
    - **'currency'**: For columns representing money, especially if they contain symbols like '$' or ','.
    - **'percentage'**: For columns with '%' symbols or values that are clearly percentages.
4.  **Write Code**: If transformation is needed, write the body of a JavaScript function. This function receives two arguments, \`data\` and \`_util\`, and must return the transformed array of objects.
5.  **Explain**: Provide a concise 'explanation' of what you did.
**CRITICAL REQUIREMENTS:**
- You MUST provide the \`outputColumns\` array. If you don't transform the data, \`outputColumns\` should be identical to the initial schema (but with more specific types if you identified them). If you do transform it, it must accurately reflect the new structure your code creates.
- Your JavaScript code MUST include a \`return\` statement as its final operation.
**Example: Reshaping and identifying types using the utility**
- Initial Data: [{'Product': 'A', 'DateStr': 'Oct 26 2023', 'Revenue': '$1,500.00'}]
- Explanation: "Standardized the date format and converted the revenue column to a number."
- jsFunctionBody: "return data.map(row => ({ ...row, DateStr: new Date(row.DateStr).toISOString().split('T')[0], Revenue: _util.parseNumber(row.Revenue) }));"
- outputColumns: [{'name': 'Product', 'type': 'categorical'}, {'name': 'DateStr', 'type': 'date'}, {'name': 'Revenue', 'type': 'currency'}]`;
                
                const response = await withRetry(async () => {
                    const res = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${settings.openAIApiKey}`
                        },
                        body: JSON.stringify({
                            model: settings.model,
                            messages: [
                                { role: 'system', content: systemPrompt },
                                { role: 'user', content: userPrompt }
                            ],
                            response_format: { type: 'json_object' }
                        })
                    });
                    if (!res.ok) {
                        const errorData = await res.json();
                        throw new Error(errorData.error?.message || `OpenAI API error: ${res.statusText}`);
                    }
                    return res.json();
                });
                jsonStr = response.choices[0].message.content;

            } else {
                if (!settings.geminiApiKey) return { explanation: "No transformation needed as API key is not set.", jsFunctionBody: null, outputColumns: columns };
                const ai = new GoogleGenAI({ apiKey: settings.geminiApiKey });
                const prompt = `
                    You are an expert data engineer. Your task is to analyze a raw dataset and, if necessary, provide a JavaScript function to clean and reshape it into a tidy, analysis-ready format. CRITICALLY, you must also provide the schema of the NEW, transformed data with detailed data types.
                    A tidy format has: 1. Each variable as a column. 2. Each observation as a row.
                    Common problems to fix:
                    - **CRITICAL RULE on NUMBER PARSING**: This is the most common source of errors. To handle numbers that might be formatted as strings (e.g., "$1,234.56", "50%"), you are provided with a safe utility function: \`_util.parseNumber(value)\`.
                        - **YOU MUST use \`_util.parseNumber(value)\` for ALL numeric conversions.**
                        - **DO NOT use \`parseInt()\`, \`parseFloat()\`, or \`Number()\` directly.** The provided utility is guaranteed to handle various formats correctly.
                    - **CRITICAL RULE on SPLITTING NUMERIC STRINGS**: If you encounter a single string field that contains multiple comma-separated numbers (which themselves may contain commas as thousand separators, e.g., "1,234.50,5,678.00,-9,123.45"), you are provided a utility \`_util.splitNumericString(value)\` to correctly split the string into an array of number strings.
                        - **YOU MUST use this utility for this specific case.**
                        - **DO NOT use a simple \`string.split(',')\`**, as this will incorrectly break up numbers.
                        - **Example**: To parse a field 'MonthlyValues' containing "1,500.00,2,000.00", your code should be: \`const values = _util.splitNumericString(row.MonthlyValues);\` This will correctly return \`['1,500.00', '2,000.00']\`.
                    - **Distinguishing Data from Summaries**: Your most critical task is to differentiate between valid data rows and non-data rows (like summaries or metadata).
                        - A row is likely **valid data** if it has a value in its primary identifier column(s) (e.g., 'Account Code', 'Product ID') and in its metric columns.
                        - **CRITICAL: Do not confuse hierarchical data with summary rows.** Look for patterns in identifier columns where one code is a prefix of another (e.g., '50' is a parent to '5010'). These hierarchical parent rows are **valid data** representing a higher level of aggregation and MUST be kept. Your role is to reshape the data, not to pre-summarize it by removing these levels.
                        - A row is likely **non-data** and should be removed if it's explicitly a summary (e.g., contains 'Total', 'Subtotal' in a descriptive column) OR if it's metadata (e.g., the primary identifier column is empty but other columns contain text, like a section header).
                    - **Crosstab/Wide Format**: Unpivot data where column headers are values (e.g., years, regions).
                    - **Multi-header Rows**: Skip initial junk rows.
                    Dataset Columns (Initial Schema):
                    ${JSON.stringify(columns, null, 2)}
                    Sample Data (up to 20 rows):
                    ${JSON.stringify(sampleData, null, 2)}
                    ${lastError ? `On the previous attempt, your generated code failed with this error: "${lastError.message}". Please analyze the error and the data, then provide a corrected response.` : ''}
                    Your task:
                    1.  **Analyze**: Look at the initial schema and sample data.
                    2.  **Plan Transformation**: Decide if cleaning or reshaping is needed. If you identify date or time columns as strings, your function should attempt to parse them into a standard format (e.g., 'YYYY-MM-DD' for dates).
                    3.  **Define Output Schema**: Determine the exact column names and types of the data AFTER your transformation. This is the MOST important step. Be as specific as possible with the types. Use 'categorical' for text labels, 'numerical' for general numbers, but you MUST identify and use the more specific types where they apply:
                        - **'date'**: For columns containing dates (e.g., "2023-10-26", "10/26/2023").
                        - **'time'**: For columns with time values (e.g., "14:30:00").
                        - **'currency'**: For columns representing money, especially if they contain symbols like '$' or ','.
                        - **'percentage'**: For columns with '%' symbols or values that are clearly percentages.
                    4.  **Write Code**: If transformation is needed, write the body of a JavaScript function. This function receives two arguments, \`data\` and \`_util\`, and must return the transformed array of objects.
                    5.  **Explain**: Provide a concise 'explanation' of what you did.
                    **CRITICAL REQUIREMENTS:**
                    - You MUST provide the \`outputColumns\` array. If you don't transform the data, \`outputColumns\` should be identical to the initial schema (but with more specific types if you identified them). If you do transform it, it must accurately reflect the new structure your code creates.
                    - Your JavaScript code MUST include a \`return\` statement as its final operation.
                    **Example: Reshaping and identifying types using the utility**
                    - Initial Data: [{'Product': 'A', 'DateStr': 'Oct 26 2023', 'Revenue': '$1,500.00'}]
                    - Explanation: "Standardized the date format and converted the revenue column to a number."
                    - jsFunctionBody: "return data.map(row => ({ ...row, DateStr: new Date(row.DateStr).toISOString().split('T')[0], Revenue: _util.parseNumber(row.Revenue) }));"
                    - outputColumns: [{'name': 'Product', 'type': 'categorical'}, {'name': 'DateStr', 'type': 'date'}, {'name': 'Revenue', 'type': 'currency'}]
                    Your response must be a valid JSON object adhering to the provided schema.
                `;
                const response = await withRetry(() => ai.models.generateContent({
                    model: settings.model,
                    contents: prompt,
                    config: {
                        responseMimeType: 'application/json',
                        responseSchema: dataPreparationSchema,
                    },
                }));
                jsonStr = response.text.trim();
            }
            
            const plan = JSON.parse(jsonStr);
            if (plan.jsFunctionBody) {
                try {
                    const mockUtil = { 
                        parseNumber: (v) => parseFloat(String(v).replace(/[$,%]/g, '')) || 0,
                        splitNumericString: (v) => v.split(','),
                    };
                    const transformFunction = new Function('data', '_util', plan.jsFunctionBody);
                    const sampleResult = transformFunction(sampleData, mockUtil);
                    if (!Array.isArray(sampleResult)) {
                        throw new Error("Generated function did not return an array.");
                    }
                    return plan;
                } catch (e) {
                    lastError = e;
                    console.warn(`AI self-correction attempt ${i + 1} failed due to JS execution error. Retrying...`, lastError);
                    continue;
                }
            }
            if (!plan.jsFunctionBody && (!plan.outputColumns || plan.outputColumns.length === 0)) {
                plan.outputColumns = columns;
            }
            return plan;
        
        } catch (error) {
            console.error(`Error in data preparation plan generation (Attempt ${i+1}):`, error);
            lastError = error;
        }
    }

    throw new Error(`AI failed to generate a valid data preparation plan after multiple attempts. Last error: ${lastError?.message}`);
};

const generateCandidatePlans = async (columns, sampleData, settings, numPlans) => {
    const categoricalCols = columns.filter(c => c.type === 'categorical' || c.type === 'date' || c.type === 'time').map(c => c.name);
    const numericalCols = columns.filter(c => c.type === 'numerical' || c.type === 'currency' || c.type === 'percentage').map(c => c.name);
    
    let jsonStr;

    if (settings.provider === 'openai') {
        const systemPrompt = `You are a senior business intelligence analyst specializing in ERP and financial data. Your task is to generate a diverse list of insightful analysis plan candidates for a given dataset by identifying common data patterns.
You MUST respond with a single valid JSON array of plan objects, and nothing else. The JSON object must adhere to the provided schema.`;
        const userPrompt = `Dataset columns:
- Categorical: ${categoricalCols.join(', ')}
- Numerical: ${numericalCols.join(', ')}
Sample Data (first 5 rows):
${JSON.stringify(sampleData, null, 2)}
Please generate up to ${numPlans} diverse analysis plans.
**CRITICAL: Think like a Business/ERP Analyst.**
1.  **Identify Key Metrics**: First, find the columns that represent measurable values. Look for names like 'VALUE', 'AMOUNT', 'SALES', 'COST', 'QUANTITY', 'PRICE'. These are almost always the columns you should be aggregating (e.g., using 'sum' or 'avg').
2.  **Identify Dimensions**: Next, find columns that describe the data. Look for names ending in 'CODE', 'ID', 'TYPE', 'CATEGORY', or containing 'NAME', 'DESCRIPTION', 'PROJECT', 'REGION'. These are your primary grouping columns (dimensions).
3.  **Find Relationships**: Codes and descriptions often go together (e.g., 'PROJECT_CODE' and 'PROJECT_DESCRIPTION'). A very valuable analysis is to group by a description column (which is more human-readable for a chart) and sum a value column.
4.  **Prioritize High-Value Aggregations**: Focus on creating plans that answer common business questions like 'What are our top revenue sources?', 'Where are the biggest costs?', or 'How are items distributed across categories?'. A simple 'count' is less valuable than a 'sum' of a 'VALUE' or 'AMOUNT' column.
**Example Task**: Given columns ['CODE', 'DESCRIPTION', 'PROJECT_CODE', 'VALUE'], a HIGH-QUALITY plan would be:
- Title: "Sum of VALUE by DESCRIPTION"
- Aggregation: 'sum'
- groupByColumn: 'DESCRIPTION'
- valueColumn: 'VALUE'
- Chart Type: 'bar'
For each plan, choose the most appropriate chartType ('bar', 'line', 'pie', 'doughnut', 'scatter'). 
- Use 'line' for time series trends.
- Use 'bar' for most categorical comparisons, especially for "top X" style reports.
- Use 'pie' or 'doughnut' for compositions with few categories.
- Use 'scatter' to show the relationship between two numerical variables.
Rules:
- For 'scatter' plots, you MUST provide 'xValueColumn' and 'yValueColumn' (both numerical) and you MUST NOT provide 'aggregation' or 'groupByColumn'.
- Do not create plans that are too granular (e.g., grouping by a unique ID column if there are thousands of them).`;

        const response = await withRetry(async () => {
            const res = await fetch('https://api.openai.com/v1/chat/completions', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${settings.openAIApiKey}` },
                body: JSON.stringify({
                    model: settings.model,
                    messages: [{ role: 'system', content: systemPrompt }, { role: 'user', content: userPrompt }],
                    response_format: { type: 'json_object' }
                })
            });
            if (!res.ok) {
                const errorData = await res.json();
                throw new Error(errorData.error?.message || `OpenAI API error: ${res.statusText}`);
            }
            return res.json();
        });
        const resultObject = JSON.parse(response.choices[0].message.content);
        const arrayCandidate = Object.values(resultObject).find(v => Array.isArray(v));
        if (!arrayCandidate) throw new Error("OpenAI response did not contain a JSON array of plans.");
        jsonStr = JSON.stringify(arrayCandidate);
    
    } else {
        const ai = new GoogleGenAI({ apiKey: settings.geminiApiKey });
        const prompt = `
            You are a senior business intelligence analyst specializing in ERP and financial data. Your task is to generate a diverse list of insightful analysis plan candidates for a given dataset by identifying common data patterns.
            Dataset columns:
            - Categorical: ${categoricalCols.join(', ')}
            - Numerical: ${numericalCols.join(', ')}
            Sample Data (first 5 rows):
            ${JSON.stringify(sampleData, null, 2)}
            Please generate up to ${numPlans} diverse analysis plans.
            **CRITICAL: Think like a Business/ERP Analyst.**
            1.  **Identify Key Metrics**: First, find the columns that represent measurable values. Look for names like 'VALUE', 'AMOUNT', 'SALES', 'COST', 'QUANTITY', 'PRICE'. These are almost always the columns you should be aggregating (e.g., using 'sum' or 'avg').
            2.  **Identify Dimensions**: Next, find columns that describe the data. Look for names ending in 'CODE', 'ID', 'TYPE', 'CATEGORY', or containing 'NAME', 'DESCRIPTION', 'PROJECT', 'REGION'. These are your primary grouping columns (dimensions).
            3.  **Find Relationships**: Codes and descriptions often go together (e.g., 'PROJECT_CODE' and 'PROJECT_DESCRIPTION'). A very valuable analysis is to group by a description column (which is more human-readable for a chart) and sum a value column.
            4.  **Prioritize High-Value Aggregations**: Focus on creating plans that answer common business questions like 'What are our top revenue sources?', 'Where are the biggest costs?', or 'How are items distributed across categories?'. A simple 'count' is less valuable than a 'sum' of a 'VALUE' or 'AMOUNT' column.
            **Example Task**: Given columns ['CODE', 'DESCRIPTION', 'PROJECT_CODE', 'VALUE'], a HIGH-QUALITY plan would be:
            - Title: "Sum of VALUE by DESCRIPTION"
            - Aggregation: 'sum'
            - groupByColumn: 'DESCRIPTION'
            - valueColumn: 'VALUE'
            - Chart Type: 'bar'
            For each plan, choose the most appropriate chartType ('bar', 'line', 'pie', 'doughnut', 'scatter'). 
            - Use 'line' for time series trends.
            - Use 'bar' for most categorical comparisons, especially for "top X" style reports.
            - Use 'pie' or 'doughnut' for compositions with few categories.
            - Use 'scatter' to show the relationship between two numerical variables.
            Rules:
            - For 'scatter' plots, you MUST provide 'xValueColumn' and 'yValueColumn' (both numerical) and you MUST NOT provide 'aggregation' or 'groupByColumn'.
            - Do not create plans that are too granular (e.g., grouping by a unique ID column if there are thousands of them).
            Your response must be a valid JSON array of plan objects. Do not include any other text or explanations.
        `;
        const response = await withRetry(() => ai.models.generateContent({
            model: settings.model,
            contents: prompt,
            config: {
                responseMimeType: 'application/json',
                responseSchema: planSchema,
            },
        }));
        jsonStr = response.text.trim();
    }

    const plans = JSON.parse(jsonStr);
    return plans.filter((p) => p.chartType && p.title);
};

const refineAndConfigurePlans = async (plansWithData, settings) => {
    let jsonStr;
    if(settings.provider === 'openai') {
        const systemPrompt = `You are a Quality Review Data Analyst. Your job is to review a list of proposed analysis plans and their data samples. Your goal is to select ONLY the most insightful and readable charts for the end-user, and configure them for the best default view. Your final output must be an array of ONLY the good, configured plan objects. Do not include the discarded plans.
You MUST respond with a single valid JSON array of plan objects, and nothing else. The JSON object must adhere to the provided schema.`;
        const userPrompt = `**Review Criteria & Rules:**
1.  **Discard Low-Value Charts**: This is your most important task. You MUST discard any plan that is not genuinely insightful.
    - **Example of a low-value chart**: A bar chart where all values are nearly identical (e.g., [77, 77, 77, 76, 78]). This shows uniformity but is not a useful visualization. DISCARD IT.
    - **Example of another low-value chart**: A pie/doughnut chart where one category makes up over 95% of the total. This is not insightful. DISCARD IT.
2.  **Discard Unreadable Charts**: If a chart groups by a high-cardinality column resulting in too many categories to be readable (e.g., more than 50 tiny bars), discard it unless it's a clear time-series line chart.
3.  **Configure for Readability**: For good, insightful charts that have a moderate number of categories (e.g., 15 to 50), you MUST add default settings to make them readable. Set \`defaultTopN\` to 8 and \`defaultHideOthers\` to \`true\`.
4.  **Keep Good Charts**: If a chart is insightful and has a reasonable number of categories (e.g., under 15), keep it as is without adding default settings.
**Proposed Plans and Data Samples:**
${JSON.stringify(plansWithData, null, 2)}`;
        
        const response = await withRetry(async () => {
            const res = await fetch('https://api.openai.com/v1/chat/completions', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${settings.openAIApiKey}` },
                body: JSON.stringify({
                    model: settings.model,
                    messages: [{ role: 'system', content: systemPrompt }, { role: 'user', content: userPrompt }],
                    response_format: { type: 'json_object' }
                })
            });
            if (!res.ok) {
                const errorData = await res.json();
                throw new Error(errorData.error?.message || `OpenAI API error: ${res.statusText}`);
            }
            return res.json();
        });
        const resultObject = JSON.parse(response.choices[0].message.content);
        const arrayCandidate = Object.values(resultObject).find(v => Array.isArray(v));
        if (!arrayCandidate) throw new Error("OpenAI response did not contain a JSON array of plans.");
        jsonStr = JSON.stringify(arrayCandidate);

    } else {
        const ai = new GoogleGenAI({ apiKey: settings.geminiApiKey });
        const prompt = `
            You are a Quality Review Data Analyst. Your job is to review a list of proposed analysis plans and their data samples. Your goal is to select ONLY the most insightful and readable charts for the end-user, and configure them for the best default view.
            **Review Criteria & Rules:**
            1.  **Discard Low-Value Charts**: This is your most important task. You MUST discard any plan that is not genuinely insightful.
                - **Example of a low-value chart**: A bar chart where all values are nearly identical (e.g., [77, 77, 77, 76, 78]). This shows uniformity but is not a useful visualization. DISCARD IT.
                - **Example of another low-value chart**: A pie/doughnut chart where one category makes up over 95% of the total. This is not insightful. DISCARD IT.
            2.  **Discard Unreadable Charts**: If a chart groups by a high-cardinality column resulting in too many categories to be readable (e.g., more than 50 tiny bars), discard it unless it's a clear time-series line chart.
            3.  **Configure for Readability**: For good, insightful charts that have a moderate number of categories (e.g., 15 to 50), you MUST add default settings to make them readable. Set \`defaultTopN\` to 8 and \`defaultHideOthers\` to \`true\`.
            4.  **Keep Good Charts**: If a chart is insightful and has a reasonable number of categories (e.g., under 15), keep it as is without adding default settings.
            5.  **Return the Result**: Your final output must be an array of ONLY the good, configured plan objects. Do not include the discarded plans.
            **Proposed Plans and Data Samples:**
            ${JSON.stringify(plansWithData, null, 2)}
            Your response must be a valid JSON array of the refined and configured plan objects, adhering to the provided schema. Do not include any other text or explanations.
        `;
        const response = await withRetry(() => ai.models.generateContent({
            model: settings.model,
            contents: prompt,
            config: {
                responseMimeType: 'application/json',
                responseSchema: planSchema,
            },
        }));
        jsonStr = response.text.trim();
    }
    
    return JSON.parse(jsonStr);
};

const generateAnalysisPlans = async (columns, sampleData, settings) => {
    const isApiKeySet = settings.provider === 'google' ? !!settings.geminiApiKey : !!settings.openAIApiKey;
    if (!isApiKeySet) throw new Error("API Key not provided.");

    try {
        const candidatePlans = await generateCandidatePlans(columns, sampleData, settings, 12);
        if (candidatePlans.length === 0) return [];

        const sampleCsvData = { fileName: 'sample', data: sampleData };
        const plansWithDataForReview = candidatePlans.map(plan => {
            try {
                const aggregatedSample = executePlan(sampleCsvData, plan);
                return { plan, aggregatedSample: aggregatedSample.slice(0, 20) };
            } catch (e) {
                return null;
            }
        }).filter((p) => p !== null && p.aggregatedSample.length > 0);
        
        if (plansWithDataForReview.length === 0) return candidatePlans.slice(0, 4);
        
        const refinedPlans = await refineAndConfigurePlans(plansWithDataForReview, settings);

        let finalPlans = refinedPlans;
        if (finalPlans.length < 4 && candidatePlans.length > finalPlans.length) {
            const refinedPlanTitles = new Set(finalPlans.map(p => p.title));
            const fallbackPlans = candidatePlans.filter(p => !refinedPlanTitles.has(p.title));
            const needed = 4 - finalPlans.length;
            finalPlans.push(...fallbackPlans.slice(0, needed));
        }

        return finalPlans.slice(0, 12);

    } catch (error) {
        console.error("Error during two-step analysis plan generation:", error);
        try {
            return await generateCandidatePlans(columns, sampleData, settings, 8);
        } catch (fallbackError) {
             console.error("Fallback plan generation also failed:", fallbackError);
             throw new Error("Failed to generate any analysis plans from AI.");
        }
    }
};

const generateSummary = async (title, data, settings) => {
    const isApiKeySet = settings.provider === 'google' ? !!settings.geminiApiKey : !!settings.openAIApiKey;
    if (!isApiKeySet) return 'AI Summaries are disabled. No API Key provided.';
    
    try {
        if (settings.provider === 'openai') {
            const languageInstruction = settings.language === 'Mandarin' 
                ? `Provide a concise, insightful summary in two languages, separated by '---'.\nFormat: English Summary --- Mandarin Summary`
                : `Provide a concise, insightful summary in ${settings.language}.`;
            const systemPrompt = `You are a business intelligence analyst. Your response must be only the summary text in the specified format. The summary should highlight key trends, outliers, or business implications. Do not just describe the data; interpret its meaning. For example, instead of "Region A has 500 sales", say "Region A is the top performer, contributing the majority of sales, which suggests a strong market presence there."`;
            const userPrompt = `The following data is for a chart titled "${title}".
Data:
${JSON.stringify(data.slice(0, 10), null, 2)} 
${data.length > 10 ? `(...and ${data.length - 10} more rows)` : ''}
${languageInstruction}`;

            const response = await withRetry(async () => {
                const res = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${settings.openAIApiKey}` },
                    body: JSON.stringify({
                        model: settings.model,
                        messages: [{ role: 'system', content: systemPrompt }, { role: 'user', content: userPrompt }],
                    })
                });
                if (!res.ok) {
                    const errorData = await res.json();
                    throw new Error(errorData.error?.message || `OpenAI API error: ${res.statusText}`);
                }
                return res.json();
            });
            return response.choices[0].message.content;

        } else {
            const ai = new GoogleGenAI({ apiKey: settings.geminiApiKey });
            const languageInstruction = settings.language === 'Mandarin' 
                ? `Provide a concise, insightful summary in two languages, separated by '---'.\nFormat: English Summary --- Mandarin Summary`
                : `Provide a concise, insightful summary in ${settings.language}.`;
            const prompt = `
                You are a business intelligence analyst.
                The following data is for a chart titled "${title}".
                Data:
                ${JSON.stringify(data.slice(0, 10), null, 2)} 
                ${data.length > 10 ? `(...and ${data.length - 10} more rows)` : ''}
                ${languageInstruction}
                The summary should highlight key trends, outliers, or business implications. Do not just describe the data; interpret its meaning.
                For example, instead of "Region A has 500 sales", say "Region A is the top performer, contributing the majority of sales, which suggests a strong market presence there."
                Your response must be only the summary text in the specified format.
            `;
            const response = await withRetry(() => ai.models.generateContent({
                model: settings.model,
                contents: prompt,
            }));
            return response.text;
        }
    } catch (error) {
        console.error("Error generating summary:", error);
        return "Failed to generate AI summary.";
    }
};

const generateCoreAnalysisSummary = async (cardContext, columns, settings) => {
    const isApiKeySet = settings.provider === 'google' ? !!settings.geminiApiKey : !!settings.openAIApiKey;
    if (!isApiKeySet || cardContext.length === 0) return "Could not generate an initial analysis summary.";

    try {
        if (settings.provider === 'openai') {
            const systemPrompt = `You are a senior data analyst. After performing an initial automated analysis of a dataset, your task is to create a concise "Core Analysis Briefing". This briefing will be shown to the user and will serve as the shared foundation of understanding for your conversation.
Your briefing should cover:
1.  **Primary Subject**: What is this data fundamentally about? (e.g., "This dataset appears to be about online sales transactions...")
2.  **Key Metrics**: What are the most important numerical columns? (e.g., "...where the key metrics are 'Sale_Amount' and 'Profit'.")
3.  **Core Dimensions**: What are the main categorical columns used for analysis? (e.g., "The data is primarily broken down by 'Region' and 'Product_Category'.")
4.  **Suggested Focus**: Based on the initial charts, what should be the focus of further analysis? (e.g., "Future analysis should focus on identifying the most profitable regions and product categories.")
Produce a single, concise paragraph in ${settings.language}. This is your initial assessment that you will share with your human counterpart.`;
            const userPrompt = `**Available Information:**
- **Dataset Columns**: ${JSON.stringify(columns.map(c => c.name))}
- **Generated Analysis Cards**: ${JSON.stringify(cardContext, null, 2)}`;
            
            const response = await withRetry(async () => {
                const res = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${settings.openAIApiKey}` },
                    body: JSON.stringify({
                        model: settings.model,
                        messages: [{ role: 'system', content: systemPrompt }, { role: 'user', content: userPrompt }],
                    })
                });
                if (!res.ok) {
                    const errorData = await res.json();
                    throw new Error(errorData.error?.message || `OpenAI API error: ${res.statusText}`);
                }
                return res.json();
            });
            return response.choices[0].message.content;

        } else {
            const ai = new GoogleGenAI({ apiKey: settings.geminiApiKey });
            const prompt = `
                You are a senior data analyst. After performing an initial automated analysis of a dataset, your task is to create a concise "Core Analysis Briefing". This briefing will be shown to the user and will serve as the shared foundation of understanding for your conversation.
                Based on the columns and the analysis cards you have just generated, summarize the dataset's primary characteristics.
                Your briefing should cover:
                1.  **Primary Subject**: What is this data fundamentally about? (e.g., "This dataset appears to be about online sales transactions...")
                2.  **Key Metrics**: What are the most important numerical columns? (e.g., "...where the key metrics are 'Sale_Amount' and 'Profit'.")
                3.  **Core Dimensions**: What are the main categorical columns used for analysis? (e.g., "The data is primarily broken down by 'Region' and 'Product_Category'.")
                4.  **Suggested Focus**: Based on the initial charts, what should be the focus of further analysis? (e.g., "Future analysis should focus on identifying the most profitable regions and product categories.")
                **Available Information:**
                - **Dataset Columns**: ${JSON.stringify(columns.map(c => c.name))}
                - **Generated Analysis Cards**: ${JSON.stringify(cardContext, null, 2)}
                Produce a single, concise paragraph in ${settings.language}. This is your initial assessment that you will share with your human counterpart.
            `;
            const response = await withRetry(() => ai.models.generateContent({
                model: settings.model,
                contents: prompt,
            }));
            return response.text;
        }
    } catch (error) {
        console.error("Error generating core analysis summary:", error);
        return "An error occurred while the AI was forming its initial analysis.";
    }
};

const proactiveInsightSchema = {
    type: Type.OBJECT,
    properties: {
        insight: { type: Type.STRING, description: "A concise, user-facing message describing the single most important finding." },
        cardId: { type: Type.STRING, description: "The ID of the card where this insight was observed." },
    },
    required: ['insight', 'cardId'],
};

const generateProactiveInsights = async (cardContext, settings) => {
    const isApiKeySet = settings.provider === 'google' ? !!settings.geminiApiKey : !!settings.openAIApiKey;
    if (!isApiKeySet || cardContext.length === 0) return null;

    try {
        let jsonStr;
        if (settings.provider === 'openai') {
             const systemPrompt = `You are a proactive data analyst. Review the following summaries of data visualizations. Your task is to identify the single most commercially significant or surprising insight. This could be a major trend, a key outlier, or a dominant category that has clear business implications. Your response must be a single JSON object with 'insight' and 'cardId' keys.`;
             const userPrompt = `**Generated Analysis Cards & Data Samples:**
${JSON.stringify(cardContext, null, 2)}

Your Task:
1.  **Analyze**: Review all the cards provided.
2.  **Identify**: Find the ONE most important finding. Don't list everything, just the top insight.
3.  **Formulate**: Write a concise, user-facing message in ${settings.language} that explains this insight (e.g., "I noticed that sales in August were unusually high, you might want to investigate what caused this spike.").
4.  **Respond**: Return a JSON object containing this message and the ID of the card it relates to.`;
            
            const response = await withRetry(async () => {
                const res = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${settings.openAIApiKey}` },
                    body: JSON.stringify({
                        model: settings.model,
                        messages: [{ role: 'system', content: systemPrompt }, { role: 'user', content: userPrompt }],
                        response_format: { type: 'json_object' }
                    })
                });
                if (!res.ok) {
                    const errorData = await res.json();
                    throw new Error(errorData.error?.message || `OpenAI API error: ${res.statusText}`);
                }
                return res.json();
            });
            jsonStr = response.choices[0].message.content;
        
        } else {
            const ai = new GoogleGenAI({ apiKey: settings.geminiApiKey });
            const prompt = `
                You are a proactive data analyst. Review the following summaries of data visualizations you have created. Your task is to identify the single most commercially significant or surprising insight. This could be a major trend, a key outlier, or a dominant category that has clear business implications.
                
                **Generated Analysis Cards & Data Samples:**
                ${JSON.stringify(cardContext, null, 2)}

                Your Task:
                1.  **Analyze**: Review all the cards provided.
                2.  **Identify**: Find the ONE most important finding. Don't list everything, just the top insight.
                3.  **Formulate**: Write a concise, user-facing message in ${settings.language} that explains this insight (e.g., "I noticed that sales in August were unusually high, you might want to investigate what caused this spike.").
                4.  **Respond**: Return a JSON object containing this message and the ID of the card it relates to.
                
                Your response must be a valid JSON object adhering to the provided schema.
            `;
            const response = await withRetry(() => ai.models.generateContent({
                model: settings.model,
                contents: prompt,
                config: {
                    responseMimeType: 'application/json',
                    responseSchema: proactiveInsightSchema,
                },
            }));
            jsonStr = response.text.trim();
        }
        return JSON.parse(jsonStr);

    } catch (error) {
        console.error("Error generating proactive insight:", error);
        return null;
    }
};

const generateFinalSummary = async (cards, settings) => {
    const isApiKeySet = settings.provider === 'google' ? !!settings.geminiApiKey : !!settings.openAIApiKey;
    if (!isApiKeySet) return 'AI Summaries are disabled. No API Key provided.';

    const summaries = cards.map(card => {
        const summaryText = card.summary.split('---')[0];
        return `Chart Title: ${card.plan.title}\nSummary: ${summaryText}`;
    }).join('\n\n');
    
    try {
        if (settings.provider === 'openai') {
            const systemPrompt = `You are a senior business strategist. You have been provided with several automated data analyses.
Your task is to synthesize these individual findings into a single, high-level executive summary in ${settings.language}.
Please provide a concise, overarching summary that connects the dots between these analyses. 
Identify the most critical business insights, potential opportunities, or risks revealed by the data as a whole.
Do not just repeat the individual summaries. Create a new, synthesized narrative.
Your response should be a single paragraph of insightful business analysis.`;
            const userPrompt = `Here are the individual analysis summaries (they are in English):
${summaries}`;
            const response = await withRetry(async () => {
                const res = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${settings.openAIApiKey}` },
                    body: JSON.stringify({
                        model: settings.model,
                        messages: [{ role: 'system', content: systemPrompt }, { role: 'user', content: userPrompt }],
                    })
                });
                if (!res.ok) {
                    const errorData = await res.json();
                    throw new Error(errorData.error?.message || `OpenAI API error: ${res.statusText}`);
                }
                return res.json();
            });
            return response.choices[0].message.content;

        } else {
            const ai = new GoogleGenAI({ apiKey: settings.geminiApiKey });
            const prompt = `
                You are a senior business strategist. You have been provided with several automated data analyses.
                Your task is to synthesize these individual findings into a single, high-level executive summary in ${settings.language}.
                Here are the individual analysis summaries (they are in English):
                ${summaries}
                Please provide a concise, overarching summary that connects the dots between these analyses. 
                Identify the most critical business insights, potential opportunities, or risks revealed by the data as a whole.
                Do not just repeat the individual summaries. Create a new, synthesized narrative.
                Your response should be a single paragraph of insightful business analysis.
            `;
            const response = await withRetry(() => ai.models.generateContent({
                model: settings.model,
                contents: prompt,
            }));
            return response.text;
        }
    } catch (error) {
        console.error("Error generating final summary:", error);
        return "Failed to generate the final AI summary.";
    }
}

const singlePlanSchema = {
    type: Type.OBJECT,
    properties: {
      chartType: { type: Type.STRING, enum: ['bar', 'line', 'pie', 'doughnut', 'scatter'], description: 'Type of chart to generate.' },
      title: { type: Type.STRING, description: 'A concise title for the analysis.' },
      description: { type: Type.STRING, description: 'A brief explanation of what the analysis shows.' },
      aggregation: { type: Type.STRING, enum: ['sum', 'count', 'avg'], description: 'The aggregation function to apply. Omit for scatter plots.' },
      groupByColumn: { type: Type.STRING, description: 'The column to group data by (categorical). Omit for scatter plots.' },
      valueColumn: { type: Type.STRING, description: 'The column for aggregation (numerical). Not needed for "count".' },
      xValueColumn: { type: Type.STRING, description: 'The column for the X-axis of a scatter plot (numerical). Required for scatter plots.' },
      yValueColumn: { type: Type.STRING, description: 'The column for the Y-axis of a scatter plot (numerical). Required for scatter plots.' },
      defaultTopN: { type: Type.INTEGER, description: 'Optional. If the analysis has many categories, this suggests a default Top N view (e.g., 8).' },
      defaultHideOthers: { type: Type.BOOLEAN, description: 'Optional. If using defaultTopN, suggests whether to hide the "Others" category by default.' },
    },
    required: ['chartType', 'title', 'description'],
};

const multiActionChatResponseSchema = {
    type: Type.OBJECT,
    properties: {
        actions: {
            type: Type.ARRAY,
            description: "A sequence of actions for the assistant to perform.",
            items: {
                type: Type.OBJECT,
                properties: {
                    thought: { type: Type.STRING, description: "The AI's reasoning or thought process before performing the action. This explains *why* this action is being taken. This is a mandatory part of the ReAct pattern." },
                    responseType: { type: Type.STRING, enum: ['text_response', 'plan_creation', 'dom_action', 'execute_js_code', 'proceed_to_analysis'] },
                    text: { type: Type.STRING, description: "A conversational text response to the user. Required for 'text_response'." },
                    cardId: { type: Type.STRING, description: "Optional. The ID of the card this text response refers to. Used to link text to a specific chart." },
                    plan: { ...singlePlanSchema, description: "Analysis plan object. Required for 'plan_creation'." },
                    domAction: {
                        type: Type.OBJECT,
                        description: "A DOM manipulation action for the frontend to execute. Required for 'dom_action'.",
                        properties: {
                            toolName: { type: Type.STRING, enum: ['highlightCard', 'changeCardChartType', 'showCardData', 'filterCard'] },
                            args: {
                                type: Type.OBJECT,
                                description: 'Arguments for the tool. e.g., { cardId: "..." }',
                                properties: {
                                    cardId: { type: Type.STRING, description: 'The ID of the target analysis card.' },
                                    newType: { type: Type.STRING, enum: ['bar', 'line', 'pie', 'doughnut', 'scatter'], description: "For 'changeCardChartType'." },
                                    visible: { type: Type.BOOLEAN, description: "For 'showCardData'." },
                                    column: { type: Type.STRING, description: "For 'filterCard', the column to filter on." },
                                    values: { type: Type.ARRAY, items: { type: Type.STRING }, description: "For 'filterCard', the values to include." },
                                },
                                required: ['cardId'],
                            },
                        },
                        required: ['toolName', 'args']
                    },
                    code: {
                        type: Type.OBJECT,
                        description: "For 'execute_js_code', the code to run.",
                        properties: {
                            explanation: { type: Type.STRING, description: "A brief, user-facing explanation of what the code will do." },
                            jsFunctionBody: { type: Type.STRING, description: "The body of a JavaScript function that takes 'data' and returns the transformed 'data'." },
                        },
                        required: ['explanation', 'jsFunctionBody']
                    }
                },
                required: ['responseType', 'thought']
            }
        }
    },
    required: ['actions']
};

const generateChatResponse = async (columns, chatHistory, userPrompt, cardContext, settings, aiCoreAnalysisSummary, currentView, rawDataSample, longTermMemory, dataPreparationPlan) => {
    const isApiKeySet = settings.provider === 'google' ? !!settings.geminiApiKey : !!settings.openAIApiKey;
    if (!isApiKeySet) {
        return { actions: [{ responseType: 'text_response', text: 'Cloud AI is disabled. API Key not provided.', thought: 'API key is missing, so I must inform the user.' }] };
    }

    const categoricalCols = columns.filter(c => c.type === 'categorical' || c.type === 'date' || c.type === 'time').map(c => c.name);
    const numericalCols = columns.filter(c => c.type === 'numerical' || c.type === 'currency' || c.type === 'percentage').map(c => c.name);
    const recentHistory = chatHistory.slice(-10).map(m => `${m.sender === 'ai' ? 'You' : 'User'}: ${m.text}`).join('\n');
    
    try {
        let jsonStr;
        if (settings.provider === 'openai') {
            const systemPrompt = `You are an expert data analyst and business strategist, required to operate using a Reason-Act (ReAct) framework. For every action you take, you must first explain your reasoning in the 'thought' field, and then define the action itself. Your goal is to respond to the user by providing insightful analysis and breaking down your response into a sequence of these thought-action pairs. Your final conversational responses should be in ${settings.language}.
Your output MUST be a single JSON object with an "actions" key containing an array of action objects.`;
            const userPromptWithContext = `**CORE ANALYSIS BRIEFING (Your Internal Summary):**
---
${aiCoreAnalysisSummary || "No core analysis has been performed yet."}
---
**DATA PREPARATION LOG (How the raw data was initially cleaned):**
---
${dataPreparationPlan ? `Explanation: ${dataPreparationPlan.explanation}\nCode Executed: \`\`\`javascript\n${dataPreparationPlan.jsFunctionBody}\n\`\`\`` : "No AI-driven data preparation was performed."}
---
**LONG-TERM MEMORY (Relevant past context, ordered by relevance):**
---
${longTermMemory.length > 0 ? longTermMemory.join('\n---\n') : "No specific long-term memories seem relevant to this query."}
---
**Your Knowledge Base (Real-time Info):**
- **Dataset Columns**:
    - Categorical: ${categoricalCols.join(', ')}
    - Numerical: ${numericalCols.join(', ')}
- **Analysis Cards on Screen (Sample of up to 100 rows each)**:
    ${cardContext.length > 0 ? JSON.stringify(cardContext, null, 2) : "No cards yet."}
- **Raw Data Sample (first 20 rows):**
    ${rawDataSample.length > 0 ? JSON.stringify(rawDataSample, null, 2) : "No raw data available."}
**Recent Conversation (for flow):**
${recentHistory}
**The user's latest message is:** "${userPrompt}"
**Your Available Actions & Tools:**
1.  **text_response**: For conversation. If your text explains a specific card, you MUST include its 'cardId'.
2.  **plan_creation**: To create a NEW chart. Use a 'defaultTopN' of 8 for readability on high-cardinality columns.
3.  **dom_action**: To INTERACT with an EXISTING card ('highlightCard', 'changeCardChartType', 'showCardData', 'filterCard').
4.  **execute_js_code**: For COMPLEX TASKS like creating new columns or complex filtering.
5.  **proceed_to_analysis**: DEPRECATED.
**Decision-Making Process (ReAct Framework):**
- **THINK (Reason)**: First, you MUST reason about the user's request. What is their goal? Can it be answered from memory, or does it require data analysis? What is the first logical step? Formulate this reasoning and place it in the 'thought' field of your action. This field is MANDATORY for every action.
- **ACT**: Based on your thought, choose the most appropriate action from your toolset and define its parameters in the same action object.
**Multi-Step Task Planning:** For complex requests that require multiple steps (e.g., "compare X and Y, then summarize"), you MUST adopt a planner persona.
1.  **Formulate a Plan**: In the \`thought\` of your VERY FIRST action, outline your step-by-step plan. For example: \`thought: "Okay, this is a multi-step request. My plan is: 1. Isolate the data for X. 2. Create an analysis for X. 3. Isolate the data for Y. 4. Create an analysis for Y. 5. Summarize the findings from both analyses."\`
2.  **Execute the Plan**: Decompose your plan into a sequence of \`actions\`. Each action should have its own \`thought\` explaining that specific step. This allows you to chain tools together to solve the problem.
- **CRITICAL**: If the user asks where a specific data value comes from (like 'Software Product 10') or how the data was cleaned, you MUST consult the **DATA PREPARATION LOG**. Use a 'text_response' to explain the transformation in simple, non-technical language. You can include snippets of the code using markdown formatting to illustrate your point.
- **Suggest Next Steps**: After successfully answering the user's request, you should add one final \`text_response\` action to proactively suggest a logical next step or a relevant follow-up question. This guides the user and makes the analysis more conversational. Example: "Now that we've seen the regional breakdown, would you like to explore the top-performing product categories within the East region?"
- **EXAMPLE of Chaining**:
  1.  Action 1: { thought: "The user is asking for profit margin, but that column doesn't exist. I need to calculate it from 'Revenue' and 'Cost'.", responseType: 'execute_js_code', code: { ... } }
  2.  Action 2: { thought: "Now that I have the 'Profit Margin' column, I need to create a chart to find the product with the highest average margin.", responseType: 'plan_creation', plan: { ... } }
  3.  Action 3: { thought: "The chart is created. I can now see the result and answer the user's question, explaining what I did.", responseType: 'text_response', text: "I've calculated the profit margin and created a new chart. It looks like 'Product A' has the highest margin." }
- Always be conversational. Use 'text_response' actions to acknowledge the user and explain what you are doing, especially after a complex series of actions.`;
            
            const response = await withRetry(async () => {
                const res = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${settings.openAIApiKey}` },
                    body: JSON.stringify({
                        model: settings.model,
                        messages: [{ role: 'system', content: systemPrompt }, { role: 'user', content: userPromptWithContext }],
                        response_format: { type: 'json_object' }
                    })
                });
                if (!res.ok) {
                    const errorData = await res.json();
                    throw new Error(errorData.error?.message || `OpenAI API error: ${res.statusText}`);
                }
                return res.json();
            });
            jsonStr = response.choices[0].message.content;

        } else {
            const ai = new GoogleGenAI({ apiKey: settings.geminiApiKey });
            const prompt = `
                You are an expert data analyst and business strategist, required to operate using a Reason-Act (ReAct) framework. For every action you take, you must first explain your reasoning in the 'thought' field, and then define the action itself. Your goal is to respond to the user by providing insightful analysis and breaking down your response into a sequence of these thought-action pairs. Your final conversational responses should be in ${settings.language}.
                
                **CORE ANALYSIS BRIEFING (Your Internal Summary):**
                ---
                ${aiCoreAnalysisSummary || "No core analysis has been performed yet."}
                ---
                **DATA PREPARATION LOG (How the raw data was initially cleaned):**
                ---
                ${dataPreparationPlan ? `Explanation: ${dataPreparationPlan.explanation}\nCode Executed: \`\`\`javascript\n${dataPreparationPlan.jsFunctionBody}\n\`\`\`` : "No AI-driven data preparation was performed."}
                ---
                **LONG-TERM MEMORY (Relevant past context, ordered by relevance):**
                ---
                ${longTermMemory.length > 0 ? longTermMemory.join('\n---\n') : "No specific long-term memories seem relevant to this query."}
                ---
                **Your Knowledge Base (Real-time Info):**
                - **Dataset Columns**:
                    - Categorical: ${categoricalCols.join(', ')}
                    - Numerical: ${numericalCols.join(', ')}
                - **Analysis Cards on Screen (Sample of up to 100 rows each)**:
                    ${cardContext.length > 0 ? JSON.stringify(cardContext, null, 2) : "No cards yet."}
                - **Raw Data Sample (first 20 rows):**
                    ${rawDataSample.length > 0 ? JSON.stringify(rawDataSample, null, 2) : "No raw data available."}

                **Recent Conversation (for flow):**
                ${recentHistory}

                **The user's latest message is:** "${userPrompt}"

                **Your Available Actions & Tools:**
                You MUST respond by creating a sequence of one or more actions in a JSON object.
                1.  **text_response**: For conversation. If your text explains a specific card, you MUST include its 'cardId'.
                2.  **plan_creation**: To create a NEW chart. Use a 'defaultTopN' of 8 for readability on high-cardinality columns.
                3.  **dom_action**: To INTERACT with an EXISTING card ('highlightCard', 'changeCardChartType', 'showCardData', 'filterCard').
                4.  **execute_js_code**: For COMPLEX TASKS like creating new columns or complex filtering.
                5.  **proceed_to_analysis**: DEPRECATED.

                **Decision-Making Process (ReAct Framework):**
                - **THINK (Reason)**: First, you MUST reason about the user's request. What is their goal? Can it be answered from memory, or does it require data analysis? What is the first logical step? Formulate this reasoning and place it in the 'thought' field of your action. This field is MANDATORY for every action.
                - **ACT**: Based on your thought, choose the most appropriate action from your toolset and define its parameters in the same action object.
                **Multi-Step Task Planning:** For complex requests that require multiple steps (e.g., "compare X and Y, then summarize"), you MUST adopt a planner persona.
                1.  **Formulate a Plan**: In the \`thought\` of your VERY FIRST action, outline your step-by-step plan. For example: \`thought: "Okay, this is a multi-step request. My plan is: 1. Isolate the data for X. 2. Create an analysis for X. 3. Isolate the data for Y. 4. Create an analysis for Y. 5. Summarize the findings from both analyses."\`
                2.  **Execute the Plan**: Decompose your plan into a sequence of \`actions\`. Each action should have its own \`thought\` explaining that specific step. This allows you to chain tools together to solve the problem.
                - **CRITICAL**: If the user asks where a specific data value comes from (like 'Software Product 10') or how the data was cleaned, you MUST consult the **DATA PREPARATION LOG**. Use a 'text_response' to explain the transformation in simple, non-technical language. You can include snippets of the code using markdown formatting to illustrate your point.
                - **Suggest Next Steps**: After successfully answering the user's request, you should add one final \`text_response\` action to proactively suggest a logical next step or a relevant follow-up question. This guides the user and makes the analysis more conversational. Example: "Now that we've seen the regional breakdown, would you like to explore the top-performing product categories within the East region?"
                - **EXAMPLE of Chaining**:
                  1.  Action 1: { thought: "The user is asking for profit margin, but that column doesn't exist. I need to calculate it from 'Revenue' and 'Cost'.", responseType: 'execute_js_code', code: { ... } }
                  2.  Action 2: { thought: "Now that I have the 'Profit Margin' column, I need to create a chart to find the product with the highest average margin.", responseType: 'plan_creation', plan: { ... } }
                  3.  Action 3: { thought: "The chart is created. I can now see the result and answer the user's question, explaining what I did.", responseType: 'text_response', text: "I've calculated the profit margin and created a new chart. It looks like 'Product A' has the highest margin." }
                - Always be conversational. Use 'text_response' actions to acknowledge the user and explain what you are doing, especially after a complex series of actions.
                Your output MUST be a single JSON object with an "actions" key containing an array of action objects.
            `;
            const response = await withRetry(() => ai.models.generateContent({
                model: settings.model,
                contents: prompt,
                config: {
                    responseMimeType: 'application/json',
                    responseSchema: multiActionChatResponseSchema,
                },
            }));
            jsonStr = response.text.trim();
        }

        const chatResponse = JSON.parse(jsonStr);

        if (!chatResponse.actions || !Array.isArray(chatResponse.actions)) {
            throw new Error("Invalid response structure from AI: 'actions' array not found.");
        }
        return chatResponse;
    } catch (error) {
        console.error("Error generating chat response:", error);
        throw new Error(`Failed to get a valid response from the AI. ${error instanceof Error ? error.message : ''}`);
    }
};

// =================================================================================
// from components/DataTable.tsx
// =================================================================================
const DataTable = ({ data }) => {
    if (!data || data.length === 0) {
        return <p className="text-slate-500">No data to display.</p>;
    }

    const headers = Object.keys(data[0]);
    
    const formatValue = (value) => {
        if (typeof value === 'number') {
            return value.toLocaleString(undefined, { maximumFractionDigits: 2 });
        }
        return value;
    };

    return (
        <div className="w-full text-sm">
            <table className="w-full text-left">
                <thead className="bg-slate-100 text-slate-600">
                    <tr>
                        {headers.map(header => (
                            <th key={header} className="p-2 font-semibold">{header}</th>
                        ))}
                    </tr>
                </thead>
                <tbody className="bg-white">
                    {data.map((row, rowIndex) => (
                        <tr key={rowIndex} className="border-b border-slate-200 last:border-b-0">
                            {headers.map(header => (
                                <td key={`${rowIndex}-${header}`} className="p-2 text-slate-700">
                                    {formatValue(row[header])}
                                </td>
                            ))}
                        </tr>
                    ))}
                </tbody>
            </table>
        </div>
    );
};

// =================================================================================
// from components/InteractiveLegend.tsx
// =================================================================================
const InteractiveLegend = ({ data, total, groupByKey, valueKey, hiddenLabels, onLabelClick }) => {
    const COLORS = ['#4e79a7', '#f28e2c', '#e15759', '#76b7b2', '#59a14f', '#edc949', '#af7aa1', '#ff9da7', '#9c755f', '#bab0ab'];
    
    const formatValue = (value) => {
        if (typeof value === 'number') {
            return value.toLocaleString(undefined, { maximumFractionDigits: 2 });
        }
        return value;
    };

    return (
        <div className="text-sm space-y-1 max-h-48 overflow-y-auto pr-2">
            {data.map((item, index) => {
                const label = String(item[groupByKey]);
                const value = Number(item[valueKey]) || 0;
                const percentage = total > 0 ? ((value / total) * 100).toFixed(1) : '0.0';
                const isHidden = hiddenLabels.includes(label);
                const color = COLORS[index % COLORS.length];

                return (
                    <button
                        key={label}
                        onClick={() => onLabelClick(label)}
                        className={`w-full flex items-center justify-between p-1.5 rounded-md transition-all duration-200 ${isHidden ? 'opacity-50' : 'hover:bg-slate-100'}`}
                        title={`Click to ${isHidden ? 'show' : 'hide'} "${label}"`}
                    >
                        <div className="flex items-center truncate mr-2">
                            <span className="w-3 h-3 rounded-sm mr-2 flex-shrink-0" style={{ backgroundColor: isHidden ? '#9ca3af' : color }}></span>
                            <span className={`truncate text-xs ${isHidden ? 'line-through text-slate-400' : 'text-slate-700'}`}>{label}</span>
                        </div>
                        <div className="flex items-baseline ml-2 flex-shrink-0">
                            <span className={`font-semibold text-xs ${isHidden ? 'text-slate-400' : 'text-slate-800'}`}>{formatValue(value)}</span>
                            <span className="text-xs text-slate-500 ml-1.5 w-12 text-right">({percentage}%)</span>
                        </div>
                    </button>
                );
            })}
        </div>
    );
};

// =================================================================================
// from components/ChartRenderer.tsx
// =================================================================================
const ChartRenderer = forwardRef(({ chartType, data, plan, selectedIndices, onElementClick, onZoomChange, disableAnimation }, ref) => {
    const COLORS = ['#4e79a7', '#f28e2c', '#e15759', '#76b7b2', '#59a14f', '#edc949', '#af7aa1', '#ff9da7', '#9c755f', '#bab0ab'];
    const BORDER_COLORS = COLORS.map(c => `${c}B3`);
    const BG_COLORS = COLORS.map(c => `${c}80`);
    const HIGHLIGHT_COLOR = '#3b82f6';
    const HIGHLIGHT_BORDER_COLOR = '#2563eb';
    const DESELECTED_COLOR = 'rgba(107, 114, 128, 0.2)';
    const DESELECTED_BORDER_COLOR = 'rgba(107, 114, 128, 0.5)';
    let zoomPluginRegistered = false;

    const canvasRef = useRef(null);
    const chartRef = useRef(null);

    if (typeof Chart !== 'undefined' && typeof ChartZoom !== 'undefined' && !zoomPluginRegistered) {
        Chart.register(ChartZoom);
        zoomPluginRegistered = true;
    }

    useImperativeHandle(ref, () => ({
        resetZoom: () => {
            chartRef.current?.resetZoom();
        }
    }));

    useEffect(() => {
        if (!canvasRef.current || !plan) return;
        if (chartRef.current) chartRef.current.destroy();
        const ctx = canvasRef.current.getContext('2d');
        if (!ctx) return;
        
        const { groupByColumn, valueColumn, xValueColumn, yValueColumn } = plan;
        const valueKey = valueColumn || 'count';
        const hasSelection = selectedIndices.length > 0;
        
        const getColors = (baseColors) => hasSelection
            ? data.map((_, i) => selectedIndices.includes(i) ? HIGHLIGHT_COLOR : DESELECTED_COLOR)
            : baseColors;

        const getBorderColors = (baseColors) => hasSelection
            ? data.map((_, i) => selectedIndices.includes(i) ? HIGHLIGHT_BORDER_COLOR : DESELECTED_BORDER_COLOR)
            : baseColors;

        const isChartZoomedOrPanned = (chart) => {
            if (!chart || !chart.scales || !chart.scales.x) return false;
            const initialXScale = chart.getInitialScaleBounds().x;
            const currentXScale = { min: chart.scales.x.min, max: chart.scales.x.max };
            return initialXScale.min !== currentXScale.min || initialXScale.max !== currentXScale.max;
        };
        
        const commonOptions = {
            maintainAspectRatio: false,
            responsive: true,
            animation: disableAnimation ? { duration: 0 } : undefined,
            onClick: (event, elements) => {
                if (elements.length > 0) onElementClick(elements[0].index, event);
            },
            plugins: {
                legend: { display: false },
                tooltip: { backgroundColor: '#ffffff', titleColor: '#1e293b', bodyColor: '#475569', borderColor: '#e2e8f0', borderWidth: 1, titleFont: { weight: 'bold' }, bodyFont: { size: 13 }, padding: 10 },
            },
            scales: {
                x: {
                    ticks: { 
                        color: '#64748b',
                        callback: function(value) {
                            const label = this.getLabelForValue(Number(value));
                            if (typeof label === 'string' && label.length > 30) return label.substring(0, 27) + '...';
                            return label;
                        }
                    },
                    grid: { color: '#e2e8f0' } 
                },
                y: { ticks: { color: '#64748b' }, grid: { color: '#e2e8f0' } }
            }
        };

        const zoomOptions = {
             pan: { enabled: true, mode: 'xy', onPanComplete: ({ chart }) => onZoomChange(isChartZoomedOrPanned(chart)) },
             zoom: { wheel: { enabled: false }, pinch: { enabled: true }, mode: 'xy', onZoomComplete: ({ chart }) => onZoomChange(isChartZoomedOrPanned(chart)) }
        };

        const labels = groupByColumn ? data.map(d => d[groupByColumn]) : [];
        const values = valueKey ? data.map(d => d[valueKey]) : [];

        switch (chartType) {
            case 'bar':
                chartRef.current = new Chart(ctx, {
                    type: 'bar',
                    data: { labels, datasets: [{ label: valueKey, data: values, backgroundColor: getColors(BG_COLORS), borderColor: getBorderColors(BORDER_COLORS), borderWidth: 1 }] },
                    options: { ...commonOptions }
                });
                break;
            case 'line':
                chartRef.current = new Chart(ctx, {
                    type: 'line',
                    data: { labels, datasets: [{ label: valueKey, data: values, fill: false, borderColor: hasSelection ? DESELECTED_BORDER_COLOR : COLORS[0], pointBackgroundColor: getColors([COLORS[0]]), pointBorderColor: getBorderColors([BORDER_COLORS[0]]), pointRadius: hasSelection ? 5 : 3, pointHoverRadius: 7, tension: 0.1 }] },
                    options: { ...commonOptions, plugins: { ...commonOptions.plugins, zoom: zoomOptions } }
                });
                break;
            case 'pie': case 'doughnut':
                chartRef.current = new Chart(ctx, {
                    type: chartType,
                    data: { labels, datasets: [{ label: valueKey, data: values, backgroundColor: getColors(BG_COLORS), borderColor: getBorderColors(BORDER_COLORS), borderWidth: 1, offset: hasSelection ? data.map((_, i) => selectedIndices.includes(i) ? 20 : 0) : 0 }] },
                    options: { ...commonOptions, scales: { x: { display: false }, y: { display: false } } }
                });
                break;
            case 'scatter':
                if (!xValueColumn || !yValueColumn) break;
                const scatterData = data.map(d => ({ x: d[xValueColumn], y: d[yValueColumn] }));
                 chartRef.current = new Chart(ctx, {
                    type: 'scatter',
                    data: { datasets: [{ label: `${yValueColumn} vs ${xValueColumn}`, data: scatterData, backgroundColor: getColors(BG_COLORS), borderColor: getBorderColors(BORDER_COLORS), borderWidth: 1.5, pointRadius: hasSelection ? data.map((_, i) => selectedIndices.includes(i) ? 7 : 4) : 5, pointHoverRadius: hasSelection ? data.map((_, i) => selectedIndices.includes(i) ? 9 : 6) : 7 }] },
                    options: {
                        ...commonOptions,
                        scales: { x: { ...commonOptions.scales.x, title: { display: true, text: xValueColumn, color: '#64748b' } }, y: { ...commonOptions.scales.y, title: { display: true, text: yValueColumn, color: '#64748b' } } },
                        plugins: { ...commonOptions.plugins, zoom: zoomOptions }
                    }
                });
                break;
            default: break;
        }
        return () => { if (chartRef.current) chartRef.current.destroy(); };
    }, [chartType, data, plan, selectedIndices, onElementClick, onZoomChange, disableAnimation]);

    return <canvas ref={canvasRef} />;
});

// =================================================================================
// from components/ChartTypeSwitcher.tsx
// =================================================================================
const ChartTypeSwitcher = ({ currentType, onChange }) => {
    const ChartIcon = ({ type }) => {
        switch (type) {
            case 'bar': return <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path d="M2 10a1 1 0 011-1h1a1 1 0 011 1v4a1 1 0 01-1 1H3a1 1 0 01-1-1v-4zM8 8a1 1 0 011-1h1a1 1 0 011 1v6a1 1 0 01-1 1H9a1 1 0 01-1-1V8zM14 4a1 1 0 011-1h1a1 1 0 011 1v10a1 1 0 01-1 1h-1a1 1 0 01-1-1V4z" /></svg>;
            case 'line': return <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fillRule="evenodd" d="M3 3a1 1 0 000 2v8a1 1 0 001 1h12a1 1 0 100-2H5V3a1 1 0 00-2 0zm12.293 4.293a1 1 0 011.414 0l2 2a1 1 0 01-1.414 1.414L15 8.414l-2.293 2.293a1 1 0 01-1.414 0l-2-2a1 1 0 111.414-1.414L12 7.586l1.293-1.293z" clipRule="evenodd" /></svg>;
            case 'pie': return <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path d="M2 10a8 8 0 018-8v8h8a8 8 0 11-16 0z" /><path d="M12 2.252A8.014 8.014 0 0117.748 8H12V2.252z" /></svg>;
            case 'doughnut': return <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM7 10a3 3 0 116 0 3 3 0 01-6 0z" clipRule="evenodd" /></svg>;
            case 'scatter': return <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path d="M5 3a2 2 0 100 4 2 2 0 000-4zM5 13a2 2 0 100 4 2 2 0 000-4zM15 3a2 2 0 100 4 2 2 0 000-4zM15 13a2 2 0 100 4 2 2 0 000-4zM8 8a2 2 0 100 4 2 2 0 000-4zM12 8a2 2 0 100 4 2 2 0 000-4z" /></svg>;
            default: return null;
        }
    };
    const chartTypes = ['bar', 'line', 'pie', 'doughnut', 'scatter'];
    return (
        <div className="flex items-center space-x-1 bg-slate-200 p-1 rounded-md">
            {chartTypes.map(type => (
                <button
                    key={type}
                    onClick={() => onChange(type)}
                    title={`Switch to ${type} chart`}
                    className={`p-1 rounded transition-colors disabled:opacity-50 disabled:cursor-not-allowed ${currentType === type ? 'bg-blue-600 text-white' : 'text-slate-500 hover:bg-slate-300 hover:text-slate-700'}`}
                >
                    <ChartIcon type={type} />
                </button>
            ))}
        </div>
    );
};

// =================================================================================
// from components/AnalysisCard.tsx
// =================================================================================
const AnalysisCard = ({ cardData, onChartTypeChange, onToggleDataVisibility, onTopNChange, onHideOthersChange, onToggleLegendLabel }) => {
    const ExportIcon = () => <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" /></svg>;
    const ResetZoomIcon = () => <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM7 9a1 1 0 000 2h6a1 1 0 100-2H7z" clipRule="evenodd" /><path d="M12.293 5.293a1 1 0 011.414 0l2 2a1 1 0 01-1.414 1.414L13 7.414V10a1 1 0 11-2 0V7.414l-1.293 1.293a1 1 0 01-1.414-1.414l2-2zM7.707 14.707a1 1 0 01-1.414 0l-2-2a1 1 0 011.414-1.414L7 12.586V10a1 1 0 112 0v2.586l1.293-1.293a1 1 0 011.414 1.414l-2 2z" /></svg>;
    const ClearSelectionIcon = () => <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fillRule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clipRule="evenodd" /></svg>;

    const { id, plan, aggregatedData, summary, displayChartType, isDataVisible, topN, hideOthers, disableAnimation, filter, hiddenLabels = [] } = cardData;
    const cardRef = useRef(null);
    const chartRendererRef = useRef(null);

    const [isExporting, setIsExporting] = useState(false);
    const [selectedIndices, setSelectedIndices] = useState([]);
    const [isZoomed, setIsZoomed] = useState(false);
    const [showSelectionDetails, setShowSelectionDetails] = useState(true);
    
    const summaryParts = summary.split('---');
    const englishSummary = summaryParts[0]?.trim();
    const mandarinSummary = summaryParts[1]?.trim();

    const valueKey = plan.valueColumn || 'count';
    const groupByKey = plan.groupByColumn || '';

    const dataAfterFilter = useMemo(() => {
        let data = aggregatedData;
        if (filter && filter.column && filter.values.length > 0) {
            data = data.filter(row => filter.values.includes(row[filter.column]));
        }
        return data;
    }, [aggregatedData, filter]);

    const dataForLegend = useMemo(() => {
        if (plan.chartType !== 'scatter' && groupByKey && topN) {
            return applyTopNWithOthers(dataAfterFilter, groupByKey, valueKey, topN);
        }
        return dataAfterFilter;
    }, [dataAfterFilter, plan.chartType, groupByKey, topN, valueKey]);

    const dataForDisplay = useMemo(() => {
        let data = dataForLegend;
        if (topN && hideOthers) data = data.filter(row => row[groupByKey] !== 'Others');
        if (groupByKey) data = data.filter(row => !hiddenLabels.includes(String(row[groupByKey])));
        return data;
    }, [dataForLegend, topN, hideOthers, groupByKey, hiddenLabels]);

    const totalValue = useMemo(() => dataAfterFilter.reduce((sum, row) => sum + (Number(row[valueKey]) || 0), 0), [dataAfterFilter, valueKey]);

    const handleExport = async (format) => {
        if (!cardRef.current) return;
        setIsExporting(true);
        try {
            switch(format) {
                case 'png': await exportToPng(cardRef.current, plan.title); break;
                case 'csv': exportToCsv(dataForDisplay, plan.title); break;
                case 'html': await exportToHtml(cardRef.current, plan.title, dataForDisplay, summary); break;
            }
        } finally {
            setIsExporting(false);
        }
    };

    const handleChartClick = (index, event) => {
        const isMultiSelect = event.ctrlKey || event.metaKey;
        setSelectedIndices(prev => {
            if (isMultiSelect) {
                const newSelection = prev.includes(index) ? prev.filter(i => i !== index) : [...prev, index];
                return newSelection.sort((a,b) => a-b);
            }
            return prev.includes(index) ? [] : [index];
        });
    };

    const handleResetZoom = () => chartRendererRef.current?.resetZoom();
    const clearSelection = () => setSelectedIndices([]);
    const handleTopNChange = (e) => onTopNChange(id, e.target.value === 'all' ? null : parseInt(e.target.value, 10));
    
    const selectedData = selectedIndices.map(index => dataForDisplay[index]);

    return (
        <div ref={cardRef} id={id} className="bg-white rounded-lg shadow-lg p-4 flex flex-col transition-all duration-300 hover:shadow-blue-500/20 border border-slate-200">
            <div className="flex justify-between items-start gap-4 mb-2">
                <h3 className="text-lg font-bold text-slate-900 flex-1">{plan.title}</h3>
                <div className="flex items-center bg-slate-100 rounded-md p-0.5 space-x-0.5 flex-shrink-0">
                    <ChartTypeSwitcher currentType={displayChartType} onChange={(newType) => onChartTypeChange(id, newType)} />
                    <div className="relative group">
                        <button disabled={isExporting} className="p-1.5 text-slate-500 hover:text-slate-900 rounded-md transition-colors hover:bg-slate-200"><ExportIcon /></button>
                        <div className="absolute right-0 mt-2 w-36 bg-white border border-slate-200 rounded-md shadow-lg opacity-0 group-hover:opacity-100 transition-opacity z-10 pointer-events-none group-hover:pointer-events-auto">
                            <a onClick={() => handleExport('png')} className="block px-4 py-2 text-sm text-slate-700 hover:bg-slate-100 cursor-pointer rounded-t-md">Export as PNG</a>
                            <a onClick={() => handleExport('csv')} className="block px-4 py-2 text-sm text-slate-700 hover:bg-slate-100 cursor-pointer">Export as CSV</a>
                            <a onClick={() => handleExport('html')} className="block px-4 py-2 text-sm text-slate-700 hover:bg-slate-100 cursor-pointer rounded-b-md">Export as HTML</a>
                        </div>
                    </div>
                </div>
            </div>
            <p className="text-sm text-slate-500 mb-4">{plan.description}</p>
            <div className="grid gap-4 flex-grow grid-cols-1">
                <div className="relative h-64">
                     <ChartRenderer ref={chartRendererRef} chartType={displayChartType} data={dataForDisplay} plan={plan} selectedIndices={selectedIndices} onElementClick={handleChartClick} onZoomChange={setIsZoomed} disableAnimation={disableAnimation} />
                     <div className="absolute top-1 right-1 flex items-center space-x-1">
                        {selectedIndices.length > 0 && <button onClick={clearSelection} title="Clear selection" className="p-1 bg-white/50 text-slate-600 rounded-full hover:bg-slate-100 hover:text-slate-800 transition-all backdrop-blur-sm"><ClearSelectionIcon /></button>}
                        {isZoomed && <button onClick={handleResetZoom} title="Reset zoom" className="p-1 bg-white/50 text-slate-600 rounded-full hover:bg-slate-100 hover:text-slate-800 transition-all backdrop-blur-sm"><ResetZoomIcon /></button>}
                    </div>
                </div>
                {groupByKey && <div className="flex flex-col"><InteractiveLegend data={dataForLegend} total={totalValue} groupByKey={groupByKey} valueKey={valueKey} hiddenLabels={hiddenLabels} onLabelClick={(label) => onToggleLegendLabel(id, label)} /></div>}
            </div>
            {filter && <div className="text-xs text-yellow-800 bg-yellow-100 p-2 rounded-md my-3 border border-yellow-200"><b>AI Filter Active:</b> Showing where '{filter.column}' is '{filter.values.join(', ')}'. Ask AI to "clear filter" to remove.</div>}
            <div className="mt-4 border-t border-slate-200 pt-4">
                <div className="bg-slate-50 p-3 rounded-md text-sm border border-slate-200">
                    <div className="flex justify-between items-baseline mb-2">
                        <p className="font-semibold text-blue-600">AI Summary</p>
                        {plan.aggregation === 'sum' && <p className="text-xs text-slate-500">Total: <span className="font-bold text-base text-slate-800">{totalValue.toLocaleString(undefined, {maximumFractionDigits: 0})}</span></p>}
                    </div>
                    <p className="text-slate-700 text-xs">{englishSummary}</p>
                    {mandarinSummary && <p className="text-slate-500 mt-2 text-xs">{mandarinSummary}</p>}
                </div>
            </div>
            <div className="mt-4 flex items-center justify-between">
                <div><button onClick={() => onToggleDataVisibility(id)} className="text-sm text-blue-600 hover:underline">{isDataVisible ? 'Hide' : 'Show'} Full Data Table</button></div>
                {plan.chartType !== 'scatter' && aggregatedData.length > 5 && (
                    <div className="flex items-center space-x-2">
                        <label htmlFor={`top-n-${id}`} className="text-xs text-slate-500">Show</label>
                        <select id={`top-n-${id}`} value={topN || 'all'} onChange={handleTopNChange} className="bg-white border border-slate-300 text-slate-800 text-xs rounded-md py-1 px-2 focus:outline-none focus:ring-1 focus:ring-blue-500">
                            <option value="all">All</option><option value="5">Top 5</option><option value="8">Top 8</option><option value="10">Top 10</option><option value="20">Top 20</option>
                        </select>
                         {topN && <div className="flex items-center"><label htmlFor={`hide-others-${id}`} className="flex items-center space-x-1.5 text-xs text-slate-500"><input type="checkbox" id={`hide-others-${id}`} checked={hideOthers} onChange={(e) => onHideOthersChange(id, e.target.checked)} className="bg-slate-100 border-slate-300 rounded focus:ring-blue-500 text-blue-600 h-3.5 w-3.5" /><span>Hide "Others"</span></label></div>}
                    </div>
                )}
            </div>
            {selectedIndices.length > 0 && <div className="mt-4 bg-slate-50 p-3 rounded-md text-sm border border-slate-200"><button onClick={() => setShowSelectionDetails(!showSelectionDetails)} className="w-full text-left font-semibold text-blue-600 mb-1">{showSelectionDetails ? '▾' : '▸'} Selection Details ({selectedIndices.length} items)</button>{showSelectionDetails && <DataTable data={selectedData} />}</div>}
            {isDataVisible && <div className="mt-2 max-h-48 overflow-y-auto border border-slate-200 rounded-md"><DataTable data={dataForDisplay} /></div>}
        </div>
    );
};

// =================================================================================
// from components/FinalSummary.tsx
// =================================================================================
const FinalSummary = ({ summary }) => (
    <div className="bg-white border border-blue-200 rounded-lg shadow-lg p-4 mb-6">
        <h2 className="text-xl font-bold text-slate-900 mb-2">📊 Overall Insights</h2>
        <p className="text-slate-700 whitespace-pre-wrap">{summary}</p>
    </div>
);

// =================================================================================
// from components/AnalysisPanel.tsx
// =================================================================================
const AnalysisPanel = ({ cards, finalSummary, onChartTypeChange, onToggleDataVisibility, onTopNChange, onHideOthersChange, onToggleLegendLabel }) => {
    if (cards.length === 0) {
        return (
            <div className="flex items-center justify-center h-full">
                 <div className="text-center p-4">
                    <p className="text-slate-500">Your analysis results will appear here.</p>
                    <p className="text-slate-400 text-sm mt-2">The AI is generating the initial analysis...</p>
                 </div>
            </div>
        );
    }
    return (
        <div className="p-1">
            {finalSummary && <FinalSummary summary={finalSummary} />}
            <div className="grid grid-cols-1 lg:grid-cols-2 2xl:grid-cols-3 gap-6 mt-6">
                {cards.map((card) => (
                    <AnalysisCard key={card.id} cardData={card} onChartTypeChange={onChartTypeChange} onToggleDataVisibility={onToggleDataVisibility} onTopNChange={onTopNChange} onHideOthersChange={onHideOthersChange} onToggleLegendLabel={onToggleLegendLabel} />
                ))}
            </div>
        </div>
    );
};

// =================================================================================
// from components/FileUpload.tsx
// =================================================================================
const FileUpload = ({ onFileUpload, isBusy, isApiKeySet, progressMessages, fileName }) => {
    const [dragActive, setDragActive] = useState(false);
    
    const handleDrag = useCallback((e) => {
        e.preventDefault();
        e.stopPropagation();
        if (!isApiKeySet) return;
        if (e.type === "dragenter" || e.type === "dragover") setDragActive(true);
        else if (e.type === "dragleave") setDragActive(false);
    }, [isApiKeySet]);

    const handleDrop = useCallback((e) => {
        e.preventDefault();
        e.stopPropagation();
        setDragActive(false);
        if (!isApiKeySet || !e.dataTransfer.files || !e.dataTransfer.files[0]) return;
        onFileUpload(e.dataTransfer.files[0]);
    }, [onFileUpload, isApiKeySet]);
    
    const handleChange = (e) => {
        if (!isApiKeySet || !e.target.files || !e.target.files[0]) return;
        onFileUpload(e.target.files[0]);
    };

    if (isBusy && fileName) {
        return (
            <div className="flex flex-col items-center justify-center p-12 border-2 border-dashed rounded-lg border-blue-500 bg-slate-100 h-full">
                <div className="flex items-center text-xl text-slate-800 mb-4">
                    <svg className="animate-spin -ml-1 mr-3 h-6 w-6" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle><path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
                    <span>Processing "{fileName}"...</span>
                </div>
                <div className="w-full max-w-lg bg-white rounded-md p-4 max-h-64 overflow-y-auto border border-slate-200">
                    <ul className="space-y-1">
                        {progressMessages.map((msg, index) => (
                            <li key={index} className={`flex text-xs ${msg.type === 'error' ? 'text-red-600' : 'text-slate-500'}`}>
                                <span className="mr-2 text-slate-400">{msg.timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' })}</span>
                                <span>{msg.text}</span>
                            </li>
                        ))}
                    </ul>
                </div>
                <p className="mt-4 text-xs text-slate-500">All processing is done locally in your browser. Your data stays private.</p>
            </div>
        );
    }

    if (!isApiKeySet) {
        return (
             <div className="flex flex-col items-center justify-center p-12 border-2 border-dashed rounded-lg border-slate-300 h-full">
                <svg className="w-16 h-16 text-slate-400 mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="1.5" d="M12 15v2m-6.364-3.636l-1.414 1.414M21 12h-2M4 12H2m15.636-6.364l-1.414-1.414M6.364 6.364L4.95 4.95M12 3V1m0 18v-2M4.95 19.05l1.414-1.414m12.728 0l-1.414-1.414M12 6a6 6 0 100 12 6 6 0 000-12z"></path></svg>
                <h3 className="text-xl font-semibold text-slate-800">API Key Required</h3>
                <p className="mt-2 max-w-sm text-center text-slate-500">To unlock the AI analysis features, please add your Google Gemini API key in the Assistant's settings panel.</p>
                <p className="mt-6 text-xs text-slate-400">Your data remains local and private even when using the AI.</p>
             </div>
        );
    }

    return (
        <div onDragEnter={handleDrag} onDragLeave={handleDrag} onDragOver={handleDrag} onDrop={handleDrop} className={`flex flex-col items-center justify-center p-12 border-2 border-dashed rounded-lg transition-colors duration-300 h-full ${dragActive ? 'border-blue-500 bg-slate-100' : 'border-slate-300 hover:border-blue-500'}`}>
            <svg className="w-16 h-16 text-slate-400 mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="1.5" d="M9 13h6m-3-3v6m5 5H7a2 2 0 01-2-2V7a2 2 0 012-2h10a2 2 0 012 2v10a2 2 0 01-2 2z"></path></svg>
            <p className="text-xl text-slate-500 mb-2">Drag & drop your CSV file here</p>
            <p className="text-slate-400">or</p>
            <label htmlFor="file-upload" className="mt-4 cursor-pointer bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700 transition-colors">Select a file</label>
            <input id="file-upload" type="file" accept=".csv" onChange={handleChange} className="hidden" disabled={isBusy} />
            <p className="mt-4 text-xs text-slate-500">All processing is done locally in your browser. Your data stays private.</p>
        </div>
    );
};

// =================================================================================
// from components/SettingsModal.tsx
// =================================================================================
const SettingsModal = ({ isOpen, onClose, onSave, currentSettings }) => {
    const languages = ['English', 'Mandarin', 'Spanish', 'Japanese', 'French'];
    const googleModels = ['gemini-2.5-flash', 'gemini-2.5-pro'];
    const openAIModels = ['gpt-4o', 'gpt-4-turbo'];
    const [settings, setSettings] = useState(currentSettings);

    useEffect(() => { setSettings(currentSettings); }, [currentSettings, isOpen]);
    if (!isOpen) return null;

    const handleSave = () => { onSave(settings); onClose(); };
    const handleInputChange = (e) => { const { name, value } = e.target; setSettings(prev => ({ ...prev, [name]: value })); };

    const handleProviderChange = (provider) => {
        setSettings(prev => {
            const currentModelIsGoogle = googleModels.includes(prev.model);
            const currentModelIsOpenAI = openAIModels.includes(prev.model);
            let newModel = prev.model;
            if (provider === 'google' && !currentModelIsGoogle) newModel = 'gemini-2.5-pro';
            else if (provider === 'openai' && !currentModelIsOpenAI) newModel = 'gpt-4o';
            return { ...prev, provider, model: newModel };
        });
    };

    return (
        <div className="fixed inset-0 bg-slate-900 bg-opacity-50 flex items-center justify-center z-50" onClick={onClose}>
            <div className="bg-white rounded-lg shadow-xl p-6 w-full max-w-md border border-slate-200" onClick={e => e.stopPropagation()}>
                <h2 className="text-2xl font-bold text-slate-900 mb-6">Settings</h2>
                <div className="space-y-6">
                     <div>
                        <label className="block text-sm font-medium text-slate-700 mb-2">AI Provider</label>
                        <div className="flex space-x-2 rounded-lg bg-slate-200 p-1">
                            <button onClick={() => handleProviderChange('google')} className={`w-full rounded-md py-1.5 text-sm font-medium transition-colors ${settings.provider === 'google' ? 'bg-blue-600 text-white shadow' : 'text-slate-700 hover:bg-slate-300'}`}>Google Gemini</button>
                            <button onClick={() => handleProviderChange('openai')} className={`w-full rounded-md py-1.5 text-sm font-medium transition-colors ${settings.provider === 'openai' ? 'bg-blue-600 text-white shadow' : 'text-slate-700 hover:bg-slate-300'}`}>OpenAI</button>
                        </div>
                    </div>
                    {settings.provider === 'google' && (
                        <div>
                            <label htmlFor="geminiApiKey" className="block text-sm font-medium text-slate-700">Gemini API Key</label>
                            <input type="password" id="geminiApiKey" name="geminiApiKey" value={settings.geminiApiKey} onChange={handleInputChange} className="mt-1 block w-full bg-white border border-slate-300 rounded-md py-2 px-3 text-slate-900 placeholder-slate-400 focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="Enter your API key" />
                            <p className="text-xs text-slate-500 mt-1">Get your key from <a href="https://aistudio.google.com/app/apikey" target="_blank" rel="noopener noreferrer" className="text-blue-600 hover:underline">Google AI Studio</a>.</p>
                        </div>
                    )}
                    {settings.provider === 'openai' && (
                         <div>
                            <label htmlFor="openAIApiKey" className="block text-sm font-medium text-slate-700">OpenAI API Key</label>
                            <input type="password" id="openAIApiKey" name="openAIApiKey" value={settings.openAIApiKey} onChange={handleInputChange} className="mt-1 block w-full bg-white border border-slate-300 rounded-md py-2 px-3 text-slate-900 placeholder-slate-400 focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="Enter your API key (sk-...)" />
                            <p className="text-xs text-slate-500 mt-1">Get your key from <a href="https://platform.openai.com/api-keys" target="_blank" rel="noopener noreferrer" className="text-blue-600 hover:underline">OpenAI Platform</a>.</p>
                        </div>
                    )}
                    <div>
                        <label htmlFor="model" className="block text-sm font-medium text-slate-700">AI Model</label>
                        <select id="model" name="model" value={settings.model} onChange={handleInputChange} className="mt-1 block w-full bg-white border border-slate-300 rounded-md py-2 px-3 text-slate-900 focus:outline-none focus:ring-2 focus:ring-blue-500">
                            {(settings.provider === 'google' ? googleModels : openAIModels).map(model => <option key={model} value={model}>{model}</option>)}
                        </select>
                         <p className="text-xs text-slate-500 mt-1">{settings.provider === 'google' ? '`pro` is more powerful, `flash` is faster.' : '`gpt-4o` is the latest model.'}</p>
                    </div>
                    <div>
                        <label htmlFor="language" className="block text-sm font-medium text-slate-700">Agent Language</label>
                        <select id="language" name="language" value={settings.language} onChange={handleInputChange} className="mt-1 block w-full bg-white border border-slate-300 rounded-md py-2 px-3 text-slate-900 focus:outline-none focus:ring-2 focus:ring-blue-500">
                            {languages.map(lang => <option key={lang} value={lang}>{lang}</option>)}
                        </select>
                         <p className="text-xs text-slate-500 mt-1">Primary language for AI summaries and chat responses.</p>
                    </div>
                </div>
                <div className="mt-8 flex justify-end space-x-3">
                    <button onClick={onClose} className="px-4 py-2 bg-slate-200 text-slate-800 rounded-md hover:bg-slate-300 transition-colors">Cancel</button>
                    <button onClick={handleSave} className="px-4 py-2 bg-blue-600 text-white font-semibold rounded-md hover:bg-blue-700 transition-colors">Save Settings</button>
                </div>
            </div>
        </div>
    );
};

// =================================================================================
// from components/HistoryPanel.tsx
// =================================================================================
const HistoryPanel = ({ isOpen, onClose, reports, onLoadReport, onDeleteReport }) => {
    const CloseIcon = () => <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" /></svg>;
    const DeleteIcon = () => <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /></svg>;

    if (!isOpen) return null;
    const handleDelete = (e, id, filename) => {
        e.stopPropagation();
        if (window.confirm(`Are you sure you want to delete the report for "${filename}"? This cannot be undone.`)) onDeleteReport(id);
    };

    return (
        <div className="fixed inset-0 bg-slate-900 bg-opacity-50 flex items-center justify-center z-50" onClick={onClose}>
            <div className="bg-white rounded-lg shadow-xl p-6 w-full max-w-2xl h-full max-h-[80vh] border border-slate-200 flex flex-col" onClick={e => e.stopPropagation()}>
                <div className="flex justify-between items-center mb-4">
                     <h2 className="text-2xl font-bold text-slate-900">Analysis History</h2>
                     <button onClick={onClose} className="p-1 text-slate-500 rounded-full hover:bg-slate-100 hover:text-slate-800 transition-colors" title="Close History"><CloseIcon /></button>
                </div>
                <div className="flex-grow overflow-y-auto pr-2">
                    {reports.length === 0 ? (
                        <div className="flex items-center justify-center h-full"><p className="text-slate-500">No past reports found. Upload a CSV to start.</p></div>
                    ) : (
                        <ul className="space-y-3">
                            {reports.map(report => {
                                const isCurrentSession = report.id === CURRENT_SESSION_KEY;
                                return (
                                <li key={report.id}>
                                    <div onClick={() => !isCurrentSession && onLoadReport(report.id)} className={`block p-4 bg-slate-50 rounded-lg transition-all ${isCurrentSession ? 'ring-2 ring-blue-500 cursor-default' : 'hover:bg-slate-100 hover:ring-2 hover:ring-blue-500 cursor-pointer'}`}>
                                        <div className="flex justify-between items-center">
                                            <div>
                                                <p className="font-semibold text-slate-800 truncate">{isCurrentSession ? <span className="text-blue-600 font-bold">[Current Session] </span> : null}{report.filename}</p>
                                                <p className="text-sm text-slate-500">Last saved: {new Date(report.updatedAt).toLocaleString()}</p>
                                            </div>
                                            {!isCurrentSession && <button onClick={(e) => handleDelete(e, report.id, report.filename)} className="p-2 text-slate-500 rounded-full hover:bg-red-100 hover:text-red-600 transition-colors flex-shrink-0 ml-4" title="Delete Report"><DeleteIcon /></button>}
                                        </div>
                                    </div>
                                </li>
                                );
                            })}
                        </ul>
                    )}
                </div>
                <p className="text-xs text-slate-500 mt-4 text-center">Your reports are saved securely in your browser's IndexedDB.</p>
            </div>
        </div>
    );
};

// =================================================================================
// from components/MemoryPanel.tsx
// =================================================================================
const MemoryPanel = ({ isOpen, onClose }) => {
    const CloseIcon = () => <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" /></svg>;
    const DeleteIcon = () => <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /></svg>;
    const MEMORY_CAPACITY_KB = 5 * 1024;

    const [documents, setDocuments] = useState([]);
    const [searchQuery, setSearchQuery] = useState('');
    const [searchResults, setSearchResults] = useState([]);
    const [isSearching, setIsSearching] = useState(false);
    const [highlightedDocText, setHighlightedDocText] = useState(null);

    const isModelReady = vectorStore.getIsInitialized();

    const refreshDocuments = useCallback(() => { setDocuments(vectorStore.getDocuments()); }, []);
    const memoryUsage = useMemo(() => {
        if (documents.length === 0) return 0;
        const textSize = documents.reduce((acc, doc) => acc + (doc.text.length * 2), 0);
        const embeddingSize = documents.length * 384 * 4;
        return (textSize + embeddingSize) / 1024;
    }, [documents]);

    useEffect(() => {
        if (isOpen) refreshDocuments();
        else { setSearchQuery(''); setSearchResults([]); setHighlightedDocText(null); }
    }, [isOpen, refreshDocuments]);
    
    const handleSearch = async (e) => {
        e.preventDefault();
        if (!searchQuery.trim() || !isModelReady) return;
        setIsSearching(true);
        setHighlightedDocText(null);
        const results = await vectorStore.search(searchQuery, 5);
        setSearchResults(results);
        setIsSearching(false);
    };

    const handleDelete = (id) => {
        if (window.confirm('Are you sure you want to delete this memory item?')) { vectorStore.deleteDocument(id); refreshDocuments(); }
    };
    
    const handleClearAll = () => {
        if (window.confirm('Are you sure you want to clear all items from the AI\'s memory? This cannot be undone.')) { vectorStore.clear(); refreshDocuments(); setSearchResults([]); }
    };
    
    const handleSearchResultClick = (text) => {
        setHighlightedDocText(text);
        const element = document.getElementById(`memory-doc-${text.substring(0, 30)}`);
        element?.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }

    if (!isOpen) return null;
    const memoryUsagePercentage = Math.min((memoryUsage / MEMORY_CAPACITY_KB) * 100, 100);

    return (
        <div className="fixed inset-0 bg-slate-900 bg-opacity-50 flex items-center justify-center z-50 transition-opacity" onClick={onClose}>
            <div className="bg-white rounded-lg shadow-xl p-6 w-full max-w-4xl h-full max-h-[85vh] border border-slate-200 flex flex-col" onClick={e => e.stopPropagation()}>
                <header className="flex justify-between items-start mb-4 flex-shrink-0">
                     <div>
                        <div className="flex items-center space-x-3"><span className="text-3xl">🧠</span><h2 className="text-2xl font-bold text-slate-900">AI Long-Term Memory</h2></div>
                        <div className="mt-2 pl-12">
                             <div className="flex items-baseline space-x-2 text-sm text-slate-500">
                                <span>{documents.length} items</span><span className="text-slate-300">|</span><span>Using ~{memoryUsage.toFixed(2)} KB</span>
                             </div>
                             <div className="w-full bg-slate-200 rounded-full h-1.5 mt-1"><div className="bg-blue-600 h-1.5 rounded-full" style={{ width: `${memoryUsagePercentage}%` }}></div></div>
                        </div>
                     </div>
                     <button onClick={onClose} className="p-1 text-slate-500 rounded-full hover:bg-slate-100 hover:text-slate-800 transition-colors" title="Close"><CloseIcon /></button>
                </header>
                <div className="flex-grow grid md:grid-cols-2 gap-6 min-h-0">
                    <div className="flex flex-col min-h-0">
                         <div className="mb-4 p-4 bg-slate-50 border border-slate-200 rounded-lg flex-shrink-0">
                            <h3 className="font-semibold text-slate-800 mb-2">Test Similarity Search</h3>
                            <form onSubmit={handleSearch} className="flex items-center space-x-2">
                                <input type="text" value={searchQuery} onChange={(e) => setSearchQuery(e.target.value)} placeholder={isModelReady ? "Enter query to find memories..." : "Memory model is loading..."} disabled={!isModelReady || isSearching} className="flex-grow bg-white border border-slate-300 rounded-md py-1.5 px-3 text-slate-900 placeholder-slate-400 focus:outline-none focus:ring-1 focus:ring-blue-500 disabled:opacity-50" />
                                <button type="submit" disabled={!isModelReady || isSearching || !searchQuery.trim()} className="px-4 py-1.5 bg-blue-600 text-white font-semibold rounded-md hover:bg-blue-700 transition-colors disabled:bg-blue-300 disabled:cursor-not-allowed">{isSearching ? '...' : 'Search'}</button>
                            </form>
                        </div>
                        <div className="flex-grow overflow-y-auto pr-2">
                            {searchResults.length > 0 && (
                                <div className="space-y-2">
                                    <h4 className="text-sm font-medium text-slate-600">Top Results:</h4>
                                    {searchResults.map((result, index) => (
                                        <div key={index} onClick={() => handleSearchResultClick(result.text)} className="bg-white p-2.5 border border-slate-200 rounded-lg text-xs cursor-pointer hover:border-blue-500 hover:ring-1 hover:ring-blue-500">
                                            <div className="flex justify-between items-center mb-1"><p className="text-slate-700 font-semibold">Match</p><p className="text-blue-600 font-bold">{(result.score * 100).toFixed(1)}%</p></div>
                                            <div className="w-full bg-slate-200 rounded-full h-1 mb-2"><div className="bg-blue-500 h-1 rounded-full" style={{ width: `${result.score * 100}%`}}></div></div>
                                            <p className="text-slate-600 italic">"{result.text}"</p>
                                        </div>
                                    ))}
                                </div>
                            )}
                        </div>
                    </div>
                    <div className="flex flex-col min-h-0">
                        <div className="flex justify-between items-center mb-2 flex-shrink-0">
                            <h3 className="font-semibold text-slate-800">All Stored Memories ({documents.length})</h3>
                            {documents.length > 0 && <button onClick={handleClearAll} className="text-xs text-red-600 hover:underline">Clear All</button>}
                        </div>
                        <div className="flex-grow overflow-y-auto pr-2 border-t border-slate-200 pt-2">
                            {documents.length === 0 ? (
                                <div className="flex items-center justify-center h-full text-slate-500 text-sm"><p>The AI's memory is currently empty.</p></div>
                            ) : (
                                <ul className="space-y-2">
                                    {documents.map(doc => (
                                        <li key={doc.id} id={`memory-doc-${doc.text.substring(0, 30)}`} className={`p-3 bg-slate-50 rounded-lg text-sm text-slate-800 border border-slate-200 flex justify-between items-start group transition-all duration-300 ${highlightedDocText === doc.text ? 'border-blue-500 ring-2 ring-blue-500' : ''}`}>
                                            <p className="flex-grow pr-4 break-words">{doc.text}</p>
                                            <button onClick={() => handleDelete(doc.id)} className="p-1 text-slate-400 rounded-full hover:bg-red-100 hover:text-red-600 transition-colors opacity-0 group-hover:opacity-100 flex-shrink-0" title="Delete Memory"><DeleteIcon /></button>
                                        </li>
                                    ))}
                                </ul>
                            )}
                        </div>
                    </div>
                </div>
            </div>
        </div>
    );
};

// =================================================================================
// from components/SpreadsheetTable.tsx
// =================================================================================
const SpreadsheetTable = ({ data, sortConfig, onSort, columnWidths, onColumnResizeStart }) => {
    const ROWS_PER_PAGE = 50;
    const SortIcon = ({ direction }) => {
        if (!direction) return <span className="text-slate-400">↕</span>;
        return direction === 'ascending' ? <span className="text-slate-800">↑</span> : <span className="text-slate-800">↓</span>;
    };

    const [currentPage, setCurrentPage] = useState(0);

    if (!data || data.length === 0) return <p className="text-slate-500 p-4 text-center">No data matches your search.</p>;

    const headers = Object.keys(data[0]);
    const totalPages = Math.ceil(data.length / ROWS_PER_PAGE);
    const startIndex = currentPage * ROWS_PER_PAGE;
    const paginatedData = data.slice(startIndex, startIndex + ROWS_PER_PAGE);

    const handlePrevPage = () => setCurrentPage(prev => Math.max(0, prev - 1));
    const handleNextPage = () => setCurrentPage(prev => Math.min(totalPages - 1, prev + 1));
    
    const formatValue = (value) => {
        if (typeof value === 'number') return value.toLocaleString(undefined, { maximumFractionDigits: 2 });
        return value;
    };
    
    const getColumnLetter = (index) => {
        let temp, letter = '';
        while (index >= 0) { temp = index % 26; letter = String.fromCharCode(temp + 65) + letter; index = Math.floor(index / 26) - 1; }
        return letter;
    }

    return (
        <div className="w-full text-sm h-full flex flex-col">
            <div className="flex-grow overflow-auto">
                <table className="w-full text-left border-collapse" style={{ tableLayout: 'fixed' }}>
                    <thead className="bg-slate-100 text-slate-600 sticky top-0 z-10">
                        <tr>
                            <th className="p-2 font-semibold text-slate-500 text-center sticky left-0 z-20 bg-slate-100 border-r border-slate-200" style={{width: '60px'}}>#</th>
                            {headers.map((header, index) => (
                                <th key={header} className="p-2 font-semibold whitespace-nowrap border-r border-l border-slate-200 relative" style={{ width: columnWidths[header] || 150 }}>
                                    <button onClick={() => onSort(header)} className="flex items-center justify-between w-full h-full">
                                        <span className="truncate" title={header}>{getColumnLetter(index)} - {header}</span>
                                        <SortIcon direction={sortConfig?.key === header ? sortConfig.direction : undefined} />
                                    </button>
                                    <div onMouseDown={(e) => onColumnResizeStart(header, e)} className="absolute top-0 right-0 h-full w-2 cursor-col-resize z-30" />
                                </th>
                            ))}
                        </tr>
                    </thead>
                    <tbody className="bg-white">
                        {paginatedData.map((row, rowIndex) => (
                            <tr key={rowIndex} className="border-b border-slate-200 last:border-b-0 hover:bg-slate-50">
                                <td className="p-2 text-slate-400 text-center sticky left-0 z-10 bg-white border-r border-slate-200" style={{width: '60px'}}>{startIndex + rowIndex + 1}</td>
                                {headers.map(header => (
                                    <td key={`${rowIndex}-${header}`} className="p-2 text-slate-700 whitespace-nowrap overflow-hidden text-ellipsis border-r border-l border-slate-200">{formatValue(row[header])}</td>
                                ))}
                            </tr>
                        ))}
                    </tbody>
                </table>
            </div>
            {totalPages > 1 && (
                <div className="flex justify-between items-center p-2 bg-slate-100 border-t border-slate-200 flex-shrink-0">
                    <span className="text-xs text-slate-500">Showing {startIndex + 1} - {Math.min(startIndex + ROWS_PER_PAGE, data.length)} of {data.length} rows</span>
                    <div className="flex items-center space-x-2">
                        <button onClick={handlePrevPage} disabled={currentPage === 0} className="px-2 py-1 text-xs bg-slate-200 rounded disabled:opacity-50 hover:bg-slate-300">Previous</button>
                        <span className="text-xs text-slate-500">Page {currentPage + 1} of {totalPages}</span>
                        <button onClick={handleNextPage} disabled={currentPage === totalPages - 1} className="px-2 py-1 text-xs bg-slate-200 rounded disabled:opacity-50 hover:bg-slate-300">Next</button>
                    </div>
                </div>
            )}
        </div>
    );
};

// =================================================================================
// from components/SpreadsheetPanel.tsx
// =================================================================================
const SpreadsheetPanel = ({ csvData, isVisible, onToggleVisibility }) => {
    const SearchIcon = () => <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 text-slate-400" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" /></svg>;
    const ChevronIcon = ({ isOpen }) => <svg xmlns="http://www.w3.org/2000/svg" className={`h-6 w-6 transform transition-transform duration-200 ${isOpen ? 'rotate-180' : ''}`} fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" /></svg>;

    const [sortConfig, setSortConfig] = useState(null);
    const [filterText, setFilterText] = useState('');
    const [isWholeWordSearch, setIsWholeWordSearch] = useState(false);
    
    const headers = useMemo(() => csvData.data.length > 0 ? Object.keys(csvData.data[0]) : [], [csvData.data]);
    const [columnWidths, setColumnWidths] = useState({});

    useEffect(() => {
        const initialWidths = {};
        headers.forEach(h => {
            const headerLength = h.length * 8 + 30;
            const sampleDataLength = String(csvData.data[0]?.[h] || '').length * 7;
            initialWidths[h] = Math.max(120, headerLength, sampleDataLength);
        });
        setColumnWidths(initialWidths);
    }, [headers, csvData.data]);

    const handleSort = (key) => {
        let direction = 'ascending';
        if (sortConfig && sortConfig.key === key && sortConfig.direction === 'ascending') direction = 'descending';
        setSortConfig({ key, direction });
    };

    const handleColumnResizeStart = (header, e) => {
        e.preventDefault();
        const startX = e.clientX;
        const startWidth = columnWidths[header];

        const handleMouseMove = (moveEvent) => {
            const newWidth = startWidth + (moveEvent.clientX - startX);
            if (newWidth > 60) setColumnWidths(prev => ({ ...prev, [header]: newWidth }));
        };
        const handleMouseUp = () => {
            document.removeEventListener('mousemove', handleMouseMove);
            document.removeEventListener('mouseup', handleMouseUp);
            document.body.style.cursor = '';
        };
        document.body.style.cursor = 'col-resize';
        document.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('mouseup', handleMouseUp);
    };

    const processedData = useMemo(() => {
        let dataToProcess = [...csvData.data];
        if (filterText) {
            if (isWholeWordSearch) {
                const escapedFilter = filterText.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
                const regex = new RegExp(`\\b${escapedFilter}\\b`, 'i');
                dataToProcess = dataToProcess.filter(row => Object.values(row).some(value => regex.test(String(value))));
            } else {
                const lowercasedFilter = filterText.toLowerCase();
                dataToProcess = dataToProcess.filter(row => Object.values(row).some(value => String(value).toLowerCase().includes(lowercasedFilter)));
            }
        }

        if (sortConfig !== null) {
            dataToProcess.sort((a, b) => {
                const aValue = a[sortConfig.key];
                const bValue = b[sortConfig.key];
                if (aValue === null || aValue === undefined) return 1;
                if (bValue === null || bValue === undefined) return -1;
                if (typeof aValue === 'number' && typeof bValue === 'number') { return sortConfig.direction === 'ascending' ? aValue - bValue : bValue - aValue; }
                const strA = String(aValue).toLowerCase();
                const strB = String(bValue).toLowerCase();
                if (strA < strB) return sortConfig.direction === 'ascending' ? -1 : 1;
                if (strA > strB) return sortConfig.direction === 'ascending' ? 1 : -1;
                return 0;
            });
        }
        return dataToProcess;
    }, [csvData.data, sortConfig, filterText, isWholeWordSearch]);
    
    return (
        <div className="bg-white rounded-lg shadow-lg flex flex-col transition-all duration-300 border border-slate-200">
            <button onClick={onToggleVisibility} className="flex justify-between items-center p-4 cursor-pointer w-full text-left rounded-t-lg hover:bg-slate-50" aria-expanded={isVisible}>
                <div>
                    <h3 className="text-lg font-bold text-slate-900">Raw Data Explorer</h3>
                    <p className="text-sm text-slate-500">File: {csvData.fileName}</p>
                </div>
                <ChevronIcon isOpen={isVisible} />
            </button>
            {isVisible && (
                <div className="flex flex-col h-full p-4 pt-0">
                    <div className="flex items-center space-x-4 mb-4">
                        <div className="relative">
                            <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none"><SearchIcon /></div>
                            <input type="text" placeholder="Search table..." value={filterText} onChange={(e) => setFilterText(e.target.value)} className="bg-white border border-slate-300 rounded-md py-1.5 pl-10 pr-4 text-slate-900 placeholder-slate-400 focus:outline-none focus:ring-1 focus:ring-blue-500 w-full sm:w-64" />
                        </div>
                         <div className="flex items-center">
                            <input type="checkbox" id="whole-word-search" checked={isWholeWordSearch} onChange={(e) => setIsWholeWordSearch(e.target.checked)} className="h-4 w-4 rounded border-slate-300 bg-slate-100 text-blue-600 focus:ring-blue-500 cursor-pointer" />
                            <label htmlFor="whole-word-search" className="ml-2 text-sm text-slate-700 select-none cursor-pointer">Whole word</label>
                        </div>
                    </div>
                    <div className="flex-grow overflow-auto border border-slate-200 rounded-md" style={{maxHeight: '60vh'}}>
                         <SpreadsheetTable data={processedData} sortConfig={sortConfig} onSort={handleSort} columnWidths={columnWidths} onColumnResizeStart={handleColumnResizeStart} />
                    </div>
                </div>
            )}
        </div>
    );
};

// =================================================================================
// from components/DataPrepDebugPanel.tsx
// =================================================================================
const DataPrepDebugPanel = ({ plan, originalSample, transformedSample, isVisible, onToggleVisibility }) => {
    const ChevronIcon = ({ isOpen }) => <svg xmlns="http://www.w3.org/2000/svg" className={`h-6 w-6 transform transition-transform duration-200 ${isOpen ? 'rotate-180' : ''}`} fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" /></svg>;
    const CodeIcon = () => <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor"><path fillRule="evenodd" d="M12.316 3.051a1 1 0 01.633 1.265l-4 12a1 1 0 11-1.898-.632l4-12a1 1 0 011.265-.633zM5.707 6.293a1 1 0 010 1.414L3.414 10l2.293 2.293a1 1 0 11-1.414 1.414l-3-3a1 1 0 010-1.414l3-3a1 1 0 011.414 0zm8.586 0a1 1 0 011.414 0l3 3a1 1 0 010 1.414l-3 3a1 1 0 11-1.414-1.414L16.586 10l-2.293-2.293a1 1 0 010-1.414z" clipRule="evenodd" /></svg>;

    return (
        <div className="bg-white rounded-lg shadow-lg flex flex-col transition-all duration-300 border border-slate-200">
            <button onClick={onToggleVisibility} className="flex justify-between items-center p-4 cursor-pointer w-full text-left rounded-t-lg hover:bg-slate-50" aria-expanded={isVisible}>
                <div>
                    <h3 className="text-lg font-bold text-slate-900 flex items-center"><CodeIcon /> AI Data Transformation Log</h3>
                    <p className="text-sm text-slate-500">See how the AI cleaned and reshaped your data.</p>
                </div>
                <ChevronIcon isOpen={isVisible} />
            </button>
            {isVisible && (
                <div className="p-4 pt-0 space-y-6">
                    <div>
                        <h4 className="font-semibold text-slate-800 mb-2">AI's Plan</h4>
                        <p className="text-sm bg-slate-50 p-3 rounded-md border border-slate-200 text-slate-700 italic">"{plan.explanation}"</p>
                    </div>
                    <div>
                        <h4 className="font-semibold text-slate-800 mb-2">Transformation Code</h4>
                        <pre className="bg-slate-900 text-slate-100 p-3 rounded-md text-xs overflow-x-auto"><code>{`// AI-generated function to transform data\nfunction transform(data, _util) {\n${plan.jsFunctionBody}\n}`}</code></pre>
                    </div>
                    <div className="grid md:grid-cols-2 gap-6">
                        <div>
                            <h4 className="font-semibold text-slate-800 mb-2">Data Before (Raw Sample)</h4>
                            <div className="max-h-64 overflow-y-auto border border-slate-200 rounded-md"><DataTable data={originalSample} /></div>
                        </div>
                        <div>
                            <h4 className="font-semibold text-slate-800 mb-2">Data After (Transformed Sample)</h4>
                             <div className="max-h-64 overflow-y-auto border border-slate-200 rounded-md"><DataTable data={transformedSample} /></div>
                        </div>
                    </div>
                </div>
            )}
        </div>
    );
};

// =================================================================================
// from components/ChatPanel.tsx
// =================================================================================
const ChatPanel = ({ progressMessages, chatHistory, isBusy, onSendMessage, isApiKeySet, onToggleVisibility, onOpenSettings, onOpenMemory, onShowCard, currentView }) => {
    const HideIcon = () => <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" /></svg>;
    const SettingsIcon = () => <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" /><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" /></svg>;
    const MemoryIcon = () => <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fillRule="evenodd" d="M18 8a6 6 0 01-7.743 5.743L10 14l-1 2-1-2-1.257-.257A6 6 0 1118 8zm-6-4a1 1 0 100 2 1 1 0 000-2zM6 8a1 1 0 112 0 1 1 0 01-2 0zm2 3a1 1 0 100 2 1 1 0 000-2z" clipRule="evenodd" /></svg>;

    const [input, setInput] = useState('');
    const messagesEndRef = useRef(null);
    const timeline = [...progressMessages, ...chatHistory].sort((a, b) => a.timestamp.getTime() - b.timestamp.getTime());
    const scrollToBottom = () => messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });

    useEffect(scrollToBottom, [timeline]);
    const handleSend = (e) => { e.preventDefault(); if (input.trim() && !isBusy) { onSendMessage(input.trim()); setInput(''); } };
    const getPlaceholder = () => {
        if (!isApiKeySet) return "Set API Key in settings to chat";
        if (currentView === 'analysis_dashboard') return "Ask for a new analysis or data transformation...";
        return "Upload a file to begin chatting";
    };

    const renderMessage = (item, index) => {
        if ('sender' in item) { // ChatMessage
            if (item.type === 'ai_plan_start') {
                return <div key={`chat-${index}`} className="my-2 p-3 bg-slate-100 border border-slate-200 rounded-lg"><div className="flex items-center text-slate-700 mb-2"><span className="text-lg mr-2">⚙️</span><h4 className="font-semibold">Plan Execution</h4></div><p className="text-sm text-slate-700 whitespace-pre-wrap">{item.text}</p></div>;
            }
            if (item.type === 'ai_thinking') {
                return <div key={`chat-${index}`} className="my-2 p-3 bg-white border border-blue-200 rounded-lg"><div className="flex items-center text-blue-700 mb-2"><span className="text-lg mr-2">🧠</span><h4 className="font-semibold">AI's Initial Analysis</h4></div><p className="text-sm text-slate-700 whitespace-pre-wrap">{item.text}</p></div>;
            }
            if (item.type === 'ai_proactive_insight') {
                return <div key={`chat-${index}`} className="my-2 p-3 bg-yellow-50 border border-yellow-300 rounded-lg"><div className="flex items-center text-yellow-800 mb-2"><span className="text-lg mr-2">💡</span><h4 className="font-semibold">Proactive Insight</h4></div><p className="text-sm text-slate-700 whitespace-pre-wrap">{item.text}</p>{item.cardId && <button onClick={() => onShowCard(item.cardId)} className="mt-2 text-xs bg-yellow-100 text-yellow-800 px-2 py-1 rounded-md hover:bg-yellow-200 transition-colors w-full text-left font-medium">→ Show Related Card</button>}</div>;
            }
            if (item.sender === 'user') {
                return <div key={`chat-${index}`} className="flex justify-end"><div className="bg-blue-600 rounded-lg px-3 py-2 max-w-xs lg:max-w-md"><p className="text-sm text-white">{item.text}</p></div></div>;
            }
            return <div key={`chat-${index}`} className="flex"><div className={`rounded-lg px-3 py-2 max-w-xs lg:max-w-md ${item.isError ? 'bg-red-100' : 'bg-slate-200'}`}><p className={`text-sm ${item.isError ? 'text-red-800' : 'text-slate-800'}`}>{item.text}</p>{item.cardId && !item.isError && <button onClick={() => onShowCard(item.cardId)} className="mt-2 text-xs bg-blue-100 text-blue-700 px-2 py-1 rounded-md hover:bg-blue-200 transition-colors w-full text-left font-medium">→ Show Related Card</button>}</div></div>;
        } else { // ProgressMessage
             return <div key={`prog-${index}`} className={`flex text-xs ${item.type === 'error' ? 'text-red-600' : 'text-slate-500'}`}><span className="mr-2 text-slate-400">{item.timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</span><span>{item.text}</span></div>;
        }
    }

    return (
        <div className="flex flex-col h-full bg-slate-100 rounded-lg md:rounded-none">
            <div className="p-4 border-b border-slate-200 flex justify-between items-center relative">
                <h2 className="text-xl font-semibold text-slate-900">Assistant</h2>
                 <div className="flex items-center space-x-3">
                    <button onClick={onOpenMemory} className="p-1 text-slate-500 rounded-full hover:bg-slate-200 hover:text-slate-800 transition-colors" title="View AI Memory"><MemoryIcon /></button>
                    <button onClick={onOpenSettings} className="p-1 text-slate-500 rounded-full hover:bg-slate-200 hover:text-slate-800 transition-colors" title="Settings"><SettingsIcon /></button>
                    <button onClick={onToggleVisibility} className="p-1 text-slate-500 rounded-full hover:bg-slate-200 hover:text-slate-800 transition-colors" title="Hide Panel"><HideIcon /></button>
                </div>
                {isBusy && <div className="absolute bottom-0 left-0 right-0 h-0.5 animate-loading-shimmer" style={{backgroundImage: 'linear-gradient(to right, #bfdbfe 25%, #3b82f6 50%, #bfdbfe 75%)', backgroundSize: '200% 100%'}}></div>}
            </div>
            <div className="flex-1 p-4 overflow-y-auto space-y-4">{timeline.map(renderMessage)}<div ref={messagesEndRef} /></div>
            <div className="p-4 border-t border-slate-200 bg-white">
                <form onSubmit={handleSend}>
                    <input type="text" value={input} onChange={(e) => setInput(e.target.value)} placeholder={getPlaceholder()} disabled={isBusy || !isApiKeySet || currentView === 'file_upload'} className="w-full bg-white border border-slate-300 rounded-md py-2 px-4 text-slate-900 placeholder-slate-400 focus:outline-none focus:ring-2 focus:ring-blue-500 disabled:opacity-50" />
                </form>
                 <div className="text-xs text-slate-400 mt-2">{currentView === 'analysis_dashboard' ? 'e.g., "Sum of sales by region", or "Remove rows for USA"' : ''}</div>
            </div>
        </div>
    );
};

// =================================================================================
// from components/EditableDataTable.tsx
// =================================================================================
const EditableDataTable = ({ data }) => {
    const ROWS_PER_PAGE = 50;
    const [currentPage, setCurrentPage] = useState(0);

    if (!data || data.length === 0) {
        return <p className="text-gray-400 p-4">No data to display.</p>;
    }

    const headers = Object.keys(data[0]);
    const totalPages = Math.ceil(data.length / ROWS_PER_PAGE);
    const startIndex = currentPage * ROWS_PER_PAGE;
    const paginatedData = data.slice(startIndex, startIndex + ROWS_PER_PAGE);

    const handlePrevPage = () => setCurrentPage(prev => Math.max(0, prev - 1));
    const handleNextPage = () => setCurrentPage(prev => Math.min(totalPages - 1, prev + 1));
    
    const formatValue = (value) => {
        if (typeof value === 'number') return value.toLocaleString(undefined, { maximumFractionDigits: 2 });
        return value;
    };

    return (
        <div className="w-full text-sm bg-gray-800 rounded-lg border border-gray-700 overflow-hidden">
            <div className="overflow-x-auto">
                <table className="w-full text-left table-auto">
                    <thead className="bg-gray-700 text-gray-300 sticky top-0">
                        <tr>
                            <th className="p-2 font-semibold text-gray-400 w-12 text-center">#</th>
                            {headers.map(header => <th key={header} className="p-2 font-semibold whitespace-nowrap">{header}</th>)}
                        </tr>
                    </thead>
                    <tbody className="bg-gray-800">
                        {paginatedData.map((row, rowIndex) => (
                            <tr key={rowIndex} className="border-b border-gray-700 last:border-b-0 hover:bg-gray-700/50">
                                <td className="p-2 text-gray-500 text-center">{startIndex + rowIndex + 1}</td>
                                {headers.map(header => <td key={`${rowIndex}-${header}`} className="p-2 text-gray-400 whitespace-nowrap">{formatValue(row[header])}</td>)}
                            </tr>
                        ))}
                    </tbody>
                </table>
            </div>
            {totalPages > 1 && (
                <div className="flex justify-between items-center p-2 bg-gray-700 border-t border-gray-600">
                    <span className="text-xs text-gray-400">Showing {startIndex + 1} - {Math.min(startIndex + ROWS_PER_PAGE, data.length)} of {data.length} rows</span>
                    <div className="flex items-center space-x-2">
                        <button onClick={handlePrevPage} disabled={currentPage === 0} className="px-2 py-1 text-xs bg-gray-600 rounded disabled:opacity-50 hover:bg-gray-500">Previous</button>
                        <span className="text-xs text-gray-400">Page {currentPage + 1} of {totalPages}</span>
                        <button onClick={handleNextPage} disabled={currentPage === totalPages - 1} className="px-2 py-1 text-xs bg-gray-600 rounded disabled:opacity-50 hover:bg-gray-500">Next</button>
                    </div>
                </div>
            )}
        </div>
    );
};

// =================================================================================
// from App.tsx
// =================================================================================
const App = () => {
    const MIN_ASIDE_WIDTH = 320;
    const MAX_ASIDE_WIDTH = 800;
    const ShowAssistantIcon = () => <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z" /></svg>;
    const HistoryIcon = () => <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>;
    const NewIcon = () => <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 13h6m-3-3v6m5 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2-2z" /></svg>;
    
    const initialState = {
        currentView: 'file_upload', isBusy: false, progressMessages: [], csvData: null,
        columnProfiles: [], analysisCards: [], chatHistory: [], finalSummary: null,
        aiCoreAnalysisSummary: null, dataPreparationPlan: null, initialDataSample: null, vectorStoreDocuments: [],
    };

    const [appState, setAppState] = useState(initialState);
    const [isAsideVisible, setIsAsideVisible] = useState(true);
    const [asideWidth, setAsideWidth] = useState(window.innerWidth / 4 > MIN_ASIDE_WIDTH ? window.innerWidth / 4 : MIN_ASIDE_WIDTH);
    const [isSpreadsheetVisible, setIsSpreadsheetVisible] = useState(true);
    const [isDataPrepDebugVisible, setIsDataPrepDebugVisible] = useState(false);
    const [isSettingsModalOpen, setIsSettingsModalOpen] = useState(false);
    const [isHistoryPanelOpen, setIsHistoryPanelOpen] = useState(false);
    const [isMemoryPanelOpen, setIsMemoryPanelOpen] = useState(false);
    const [settings, setSettings] = useState(() => getSettings());
    const [reportsList, setReportsList] = useState([]);

    const isResizingAsideRef = useRef(false);
    const isMounted = useRef(false);
    const isApiKeySet = settings.provider === 'google' ? !!settings.geminiApiKey : !!settings.openAIApiKey;

    const loadReportsList = useCallback(async () => {
        const list = await getReportsList();
        if (isMounted.current) setReportsList(list);
    }, []);

    const addProgress = useCallback((message, type = 'system') => {
        if (!isMounted.current) return;
        const newMessage = { text: message, type, timestamp: new Date() };
        setAppState(prev => ({ ...prev, progressMessages: [...prev.progressMessages, newMessage] }));
    }, []);
    
    useEffect(() => { isMounted.current = true; return () => { isMounted.current = false; }; }, []);

    useEffect(() => {
        const loadInitialData = async () => {
            const currentSession = await getReport(CURRENT_SESSION_KEY);
            if (isMounted.current) {
                if (currentSession) {
                     setAppState({ ...currentSession.appState, currentView: currentSession.appState.csvData ? 'analysis_dashboard' : 'file_upload' });
                     if (currentSession.appState.vectorStoreDocuments && vectorStore.getIsInitialized()) {
                        vectorStore.rehydrate(currentSession.appState.vectorStoreDocuments);
                        addProgress('Restored AI long-term memory from last session.');
                    }
                }
                await loadReportsList();
            }
        };
        loadInitialData();
    }, [loadReportsList, addProgress]);

    useEffect(() => {
        if (!isMounted.current) return;
        const saveCurrentState = async () => {
            if (appState.csvData && appState.csvData.data.length > 0) {
                 const existingReport = await getReport(CURRENT_SESSION_KEY);
                 const stateToSave = { ...appState, vectorStoreDocuments: vectorStore.getDocuments() };
                 const currentReport = { id: CURRENT_SESSION_KEY, filename: appState.csvData.fileName || 'Current Session', createdAt: existingReport?.createdAt || new Date(), updatedAt: new Date(), appState: stateToSave };
                await saveReport(currentReport);
                if (isHistoryPanelOpen) await loadReportsList();
            }
        };
        const debounceSave = setTimeout(saveCurrentState, 1000);
        return () => clearTimeout(debounceSave);
    }, [appState, loadReportsList, isHistoryPanelOpen]);
    
    const handleSaveSettings = (newSettings) => { saveSettings(newSettings); setSettings(newSettings); };

    const handleAsideMouseMove = useCallback((e) => {
        if (!isResizingAsideRef.current) return;
        let newWidth = window.innerWidth - e.clientX;
        if (newWidth < MIN_ASIDE_WIDTH) newWidth = MIN_ASIDE_WIDTH;
        if (newWidth > MAX_ASIDE_WIDTH) newWidth = MAX_ASIDE_WIDTH;
        setAsideWidth(newWidth);
    }, []);
    
    const handleMouseUp = useCallback(() => {
        isResizingAsideRef.current = false;
        document.removeEventListener('mousemove', handleAsideMouseMove);
        document.removeEventListener('mouseup', handleMouseUp);
        document.body.style.cursor = '';
    }, [handleAsideMouseMove]);

    const handleAsideMouseDown = useCallback((e) => {
        e.preventDefault();
        isResizingAsideRef.current = true;
        document.addEventListener('mousemove', handleAsideMouseMove);
        document.addEventListener('mouseup', handleMouseUp);
        document.body.style.cursor = 'col-resize';
    }, [handleAsideMouseMove, handleMouseUp]);

    const runAnalysisPipeline = useCallback(async (plans, data, isChatRequest = false) => {
        let isFirstCardInPipeline = true;
        const processPlan = async (plan) => {
            try {
                addProgress(`Executing plan: ${plan.title}...`);
                const aggregatedData = executePlan(data, plan);
                if (aggregatedData.length === 0) {
                    addProgress(`Skipping "${plan.title}" due to empty result.`, 'error');
                    return null;
                }
                
                addProgress(`AI is summarizing: ${plan.title}...`);
                const summary = await generateSummary(plan.title, aggregatedData, settings);

                const categoryCount = aggregatedData.length;
                const shouldApplyDefaultTop8 = plan.chartType !== 'scatter' && categoryCount > 15;

                const newCard = {
                    id: `card-${Date.now()}-${Math.random()}`, plan: plan, aggregatedData: aggregatedData, summary: summary,
                    displayChartType: plan.chartType, isDataVisible: false, topN: shouldApplyDefaultTop8 ? 8 : (plan.defaultTopN || null),
                    hideOthers: shouldApplyDefaultTop8 ? true : (plan.defaultHideOthers || false),
                    disableAnimation: isChatRequest || !isFirstCardInPipeline || appState.analysisCards.length > 0, hiddenLabels: [],
                };
                
                if (isMounted.current) setAppState(prev => ({...prev, analysisCards: [...prev.analysisCards, newCard] }));
                const cardMemoryText = `[Chart: ${plan.title}] Description: ${plan.description}. AI Summary: ${summary.split('---')[0]}`;
                await vectorStore.addDocument({ id: newCard.id, text: cardMemoryText });
                addProgress(`View #${newCard.id.slice(-6)} indexed for long-term memory.`);

                isFirstCardInPipeline = false; 
                addProgress(`Saved as View #${newCard.id.slice(-6)}`);
                return newCard;
            } catch (error) {
                console.error('Error executing plan:', plan.title, error);
                const errorMessage = error instanceof Error ? error.message : String(error);
                addProgress(`Error executing plan "${plan.title}": ${errorMessage}`, 'error');
                return null;
            }
        };

        const createdCards = (await Promise.all(plans.map(processPlan))).filter(c => c !== null);

        if (!isChatRequest && isMounted.current && createdCards.length > 0) {
            addProgress('AI is forming its core understanding of the data...');
            const cardContext = createdCards.map(c => ({ id: c.id, title: c.plan.title, aggregatedDataSample: c.aggregatedData.slice(0, 10) }));
            const coreSummary = await generateCoreAnalysisSummary(cardContext, appState.columnProfiles, settings);
            
            if (isMounted.current) {
                const thinkingMessage = { sender: 'ai', text: coreSummary, timestamp: new Date(), type: 'ai_thinking' };
                setAppState(prev => ({ ...prev, aiCoreAnalysisSummary: coreSummary, chatHistory: [...prev.chatHistory, thinkingMessage] }));
                
                addProgress("Indexing core analysis for long-term memory...");
                await vectorStore.addDocument({ id: 'core-summary', text: `Core Analysis Summary: ${coreSummary}` });
                addProgress("Core analysis indexed.");
            }
            
            addProgress('AI is looking for key insights...');
            const proactiveInsight = await generateProactiveInsights(cardContext, settings);
            
            if (isMounted.current && proactiveInsight) {
                const insightMessage = { sender: 'ai', text: proactiveInsight.insight, timestamp: new Date(), type: 'ai_proactive_insight', cardId: proactiveInsight.cardId };
                setAppState(prev => ({ ...prev, chatHistory: [...prev.chatHistory, insightMessage] }));
                addProgress(`AI proactively identified an insight in View #${proactiveInsight.cardId.slice(-6)}.`);
            }

            const finalSummaryText = await generateFinalSummary(createdCards, settings);
            if(isMounted.current) setAppState(prev => ({...prev, finalSummary: finalSummaryText}));
            addProgress('Overall summary generated.');
        }
        return createdCards;
    }, [addProgress, settings, appState.analysisCards.length, appState.columnProfiles]);

    const handleInitialAnalysis = useCallback(async (dataForAnalysis) => {
        if (!dataForAnalysis || !isMounted.current) return;
        setAppState(prev => ({...prev, isBusy: true}));
        addProgress('Starting main analysis...');

        try {
            addProgress('AI is generating analysis plans...');
            const plans = await generateAnalysisPlans(appState.columnProfiles, dataForAnalysis.data.slice(0, 5), settings);
            addProgress(`AI proposed ${plans.length} plans.`);
            
            if (plans.length > 0) await runAnalysisPipeline(plans, dataForAnalysis, false);
            else addProgress('AI did not propose any analysis plans.', 'error');

        } catch (error) {
            console.error('Analysis pipeline error:', error);
            const errorMessage = error instanceof Error ? error.message : String(error);
            addProgress(`Error during analysis: ${errorMessage}`, 'error');
        } finally {
            if (isMounted.current) {
                setAppState(prev => ({ ...prev, isBusy: false }));
                addProgress('Analysis complete. Ready for chat.');
            }
        }
    }, [appState.columnProfiles, settings, runAnalysisPipeline, addProgress]);

    const handleFileUpload = useCallback(async (file) => {
        if (!isMounted.current) return;
        const currentState = appState;
        if (currentState.csvData && currentState.csvData.data.length > 0) {
             const existingSession = await getReport(CURRENT_SESSION_KEY);
             if (existingSession) {
                const archiveId = `report-${existingSession.createdAt.getTime()}`;
                await saveReport({ ...existingSession, id: archiveId, updatedAt: new Date() });
             }
        }
        
        vectorStore.clear();
        await deleteReport(CURRENT_SESSION_KEY);
        await loadReportsList();

        setAppState({ ...initialState, isBusy: true, csvData: { fileName: file.name, data: [] } });
        
        try {
            addProgress('Parsing CSV file...');
            const parsedData = await processCsv(file);
            if (!isMounted.current) return;
            addProgress(`Parsed ${parsedData.data.length} rows.`);

            setAppState(prev => ({ ...prev, initialDataSample: parsedData.data.slice(0, 20) }));
            
            let dataForAnalysis = parsedData;
            let profiles, prepPlan = null;

            if (isApiKeySet) {
                await vectorStore.init(addProgress);
                addProgress('AI is analyzing data for cleaning and reshaping...');
                const initialProfiles = profileData(dataForAnalysis.data);
                prepPlan = await generateDataPreparationPlan(initialProfiles, dataForAnalysis.data.slice(0, 20), settings);
                
                if (prepPlan && prepPlan.jsFunctionBody) {
                    addProgress(`AI Plan: ${prepPlan.explanation}`);
                    addProgress('Executing AI data transformation...');
                    const originalRowCount = dataForAnalysis.data.length;
                    dataForAnalysis.data = executeJavaScriptDataTransform(dataForAnalysis.data, prepPlan.jsFunctionBody);
                    addProgress(`Transformation complete. Row count changed from ${originalRowCount} to ${dataForAnalysis.data.length}. You can ask me how the data was cleaned.`);
                } else {
                     addProgress('AI found no necessary data transformations.');
                }
                profiles = prepPlan.outputColumns;
                addProgress('AI has defined the new data structure.');
                
                if (dataForAnalysis.data.length === 0) throw new Error('The dataset became empty after AI-driven cleaning or reshaping.');
                if (!isMounted.current) return;
                 setAppState(prev => ({ ...prev, csvData: dataForAnalysis, columnProfiles: profiles, dataPreparationPlan: prepPlan, currentView: 'analysis_dashboard' }));
                await handleInitialAnalysis(dataForAnalysis);

            } else {
                 const providerName = settings.provider === 'google' ? 'Gemini' : 'OpenAI';
                 addProgress(`API Key not set. Please add your ${providerName} API Key in the settings.`, 'error');
                 setIsSettingsModalOpen(true);
                 profiles = profileData(dataForAnalysis.data);
                 addProgress('Profiling data columns...');
                 addProgress('Data profiling complete.');
                 setAppState(prev => ({ ...prev, csvData: dataForAnalysis, columnProfiles: profiles, isBusy: false, currentView: 'analysis_dashboard' }));
                 addProgress('No API Key, skipping AI analysis. You can explore the raw data.', 'error');
            }

        } catch (error) {
            console.error('File processing error:', error);
            let errorMessage = error instanceof Error ? error.message : String(error);
            if (error instanceof Error && error.message.startsWith('AI failed to generate a valid data preparation plan')) {
                errorMessage = `The AI failed to prepare your data for analysis, even after several self-correction attempts. This can happen with very unusual or complex file formats. Please check the file or try another one. Final error: ${error.message}`;
            }
            addProgress(`File Processing Error: ${errorMessage}`, 'error');
            if (isMounted.current) setAppState(prev => ({ ...prev, isBusy: false, currentView: 'file_upload' }));
        }
    }, [addProgress, settings, loadReportsList, handleInitialAnalysis, isApiKeySet, appState]);

    const regenerateAnalyses = useCallback(async (newData) => {
        if (!isMounted.current) return;
        addProgress('Data has changed. Regenerating all analysis cards...');
        setAppState(prev => ({ ...prev, isBusy: true, analysisCards: [], finalSummary: null }));
        
        try {
            const existingPlans = appState.analysisCards.map(card => card.plan);
            if (existingPlans.length > 0) {
                const newCards = await runAnalysisPipeline(existingPlans, newData, true);
                if (isMounted.current && newCards.length > 0) {
                    const newFinalSummary = await generateFinalSummary(newCards, settings);
                    if (isMounted.current) setAppState(prev => ({ ...prev, finalSummary: newFinalSummary }));
                    addProgress('All analysis cards have been updated.');
                }
            } else {
                 addProgress('No existing analysis to update. Ready for chat.');
            }
        } catch (error) {
             console.error("Error regenerating analyses:", error);
             addProgress(`Error updating analyses: ${error instanceof Error ? error.message : String(error)}`, 'error');
        } finally {
             if (isMounted.current) setAppState(prev => ({ ...prev, isBusy: false }));
        }
    }, [appState.analysisCards, runAnalysisPipeline, addProgress, settings]);

    const executeDomAction = (action) => {
        addProgress(`AI is performing action: ${action.toolName}...`);
        setAppState(prev => {
            const newCards = [...prev.analysisCards];
            let cardUpdated = false;

            switch(action.toolName) {
                case 'highlightCard': {
                    const element = document.getElementById(action.args.cardId);
                    if (element) {
                        element.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        element.classList.add('ring-4', 'ring-blue-500', 'transition-all', 'duration-500');
                        setTimeout(() => element.classList.remove('ring-4', 'ring-blue-500'), 2500);
                    } else addProgress(`Could not find card ID ${action.args.cardId} to highlight.`, 'error');
                    break;
                }
                case 'changeCardChartType': {
                    const cardIndex = newCards.findIndex(c => c.id === action.args.cardId);
                    if (cardIndex > -1) { newCards[cardIndex].displayChartType = action.args.newType; cardUpdated = true; } 
                    else addProgress(`Could not find card ID ${action.args.cardId} to change chart type.`, 'error');
                    break;
                }
                case 'showCardData': {
                     const cardIndex = newCards.findIndex(c => c.id === action.args.cardId);
                     if (cardIndex > -1) { newCards[cardIndex].isDataVisible = action.args.visible; cardUpdated = true; } 
                     else addProgress(`Could not find card ID ${action.args.cardId} to show data for.`, 'error');
                     break;
                }
                 case 'filterCard': {
                    const cardIndex = newCards.findIndex(c => c.id === action.args.cardId);
                    if (cardIndex > -1) {
                        newCards[cardIndex].filter = action.args.values.length > 0 ? { column: action.args.column, values: action.args.values } : undefined;
                        cardUpdated = true;
                        addProgress(`AI is filtering the '${newCards[cardIndex].plan.title}' card.`);
                    } else addProgress(`Could not find card ID ${action.args.cardId} to filter.`, 'error');
                    break;
                }
                default: addProgress(`Unknown DOM action: ${action.toolName}`, 'error');
            }
            if (cardUpdated) return { ...prev, analysisCards: newCards };
            return prev;
        });
    }

     const handleChatMessage = useCallback(async (message) => {
        if (!appState.csvData || !appState.columnProfiles.length) { addProgress("Please upload a CSV file first.", "error"); return; }
        if (!isApiKeySet) {
            const providerName = settings.provider === 'google' ? 'Gemini' : 'OpenAI';
            addProgress(`API Key not set. Please add your ${providerName} API Key in the settings.`, 'error');
            setIsSettingsModalOpen(true);
            return;
        }
        if (!vectorStore.getIsInitialized()) await vectorStore.init(addProgress);
        if (!isMounted.current) return;

        const newChatMessage = { sender: 'user', text: message, timestamp: new Date(), type: 'user_message' };
        setAppState(prev => ({ ...prev, isBusy: true, chatHistory: [...prev.chatHistory, newChatMessage] }));
        await vectorStore.addDocument({id: `chat-${newChatMessage.timestamp.getTime()}-user`, text: `User asks: "${message}"`});

        try {
            const relevantMemories = await vectorStore.search(message, 5);
            const memoryContext = relevantMemories.map(r => r.text);
            if (memoryContext.length > 0) addProgress(`Found ${memoryContext.length} relevant memories.`);
            
            const cardContext = appState.analysisCards.map(c => ({ id: c.id, title: c.plan.title, aggregatedDataSample: c.aggregatedData.slice(0, 100) }));
            const response = await generateChatResponse(appState.columnProfiles, appState.chatHistory, message, cardContext, settings, appState.aiCoreAnalysisSummary, appState.currentView, appState.csvData.data.slice(0, 20), memoryContext, appState.dataPreparationPlan);
            const sleep = (ms) => new Promise(res => setTimeout(res, ms));
            const actions = response.actions;
            
            if (actions.length > 1) {
                const planText = actions[0]?.thought || `I've formulated a ${actions.length}-step plan to address your request.`;
                const planMessage = { sender: 'ai', text: planText, timestamp: new Date(), type: 'ai_plan_start' };
                if (isMounted.current) setAppState(prev => ({ ...prev, chatHistory: [...prev.chatHistory, planMessage] }));
                addProgress(`AI is executing a ${actions.length}-step plan.`);
                await sleep(1000);
            }

            for (const [index, action] of actions.entries()) {
                if (!isMounted.current) break;
                if (action.thought && (index > 0 || actions.length === 1)) {
                    addProgress(`AI Thought: ${action.thought}`);
                    await sleep(1500);
                }
                
                switch (action.responseType) {
                    case 'text_response':
                        if (action.text && isMounted.current) {
                            const aiMessage = { sender: 'ai', text: action.text, timestamp: new Date(), type: 'ai_message', cardId: action.cardId };
                            setAppState(prev => ({...prev, chatHistory: [...prev.chatHistory, aiMessage]}));
                            await vectorStore.addDocument({id: `chat-${aiMessage.timestamp.getTime()}-ai`, text: `AI responds: "${action.text}"`});
                        }
                        break;
                    case 'plan_creation': if (action.plan && appState.csvData) await runAnalysisPipeline([action.plan], appState.csvData, true); break;
                    case 'dom_action': if (action.domAction) executeDomAction(action.domAction); break;
                    case 'execute_js_code':
                        if (action.code && action.code.jsFunctionBody && appState.csvData) {
                            addProgress(`AI is performing a complex data transformation: ${action.code.explanation}`);
                            const newDataArray = executeJavaScriptDataTransform(appState.csvData.data, action.code.jsFunctionBody);
                            const newData = { ...appState.csvData, data: newDataArray };
                            const newProfiles = profileData(newData.data);
                             if (isMounted.current) {
                                setAppState(prev => ({ ...prev, csvData: newData, columnProfiles: newProfiles }));
                                await regenerateAnalyses(newData);
                                addProgress("Data transformation successful. All charts have been updated.");
                             }
                        }
                        break;
                    case 'proceed_to_analysis':
                         if (isMounted.current) {
                            const aiMessage = { sender: 'ai', text: "The initial analysis is already complete. You can ask me to create new charts or modify the data.", timestamp: new Date(), type: 'ai_message' };
                            setAppState(prev => ({...prev, chatHistory: [...prev.chatHistory, aiMessage]}));
                        }
                        break;
                    default: console.warn('Unknown AI action type:', action.responseType);
                }
                if (actions.length > 1) await sleep(750);
            }
        } catch(error) {
            console.error('Chat processing error:', error);
            const errorMessage = error instanceof Error ? error.message : String(error);
            addProgress(`Error processing chat: ${errorMessage}`, 'error');
            if (isMounted.current) {
                const aiMessage = { sender: 'ai', text: `Sorry, I had trouble with that request: ${errorMessage}. Could you try rephrasing it?`, timestamp: new Date(), type: 'ai_message', isError: true };
                setAppState(prev => ({...prev, chatHistory: [...prev.chatHistory, aiMessage]}));
            }
        } finally {
            if (isMounted.current) setAppState(prev => ({ ...prev, isBusy: false }));
        }
    }, [appState, addProgress, runAnalysisPipeline, settings, regenerateAnalyses, isApiKeySet]);
    
    const handleChartTypeChange = (cardId, newType) => setAppState(prev => ({ ...prev, analysisCards: prev.analysisCards.map(c => c.id === cardId ? {...c, displayChartType: newType} : c) }));
    const handleToggleDataVisibility = (cardId) => setAppState(prev => ({ ...prev, analysisCards: prev.analysisCards.map(c => c.id === cardId ? {...c, isDataVisible: !c.isDataVisible} : c) }));
    const handleTopNChange = (cardId, topN) => setAppState(prev => ({ ...prev, analysisCards: prev.analysisCards.map(c => c.id === cardId ? {...c, topN: topN} : c) }));
    const handleHideOthersChange = (cardId, hide) => setAppState(prev => ({ ...prev, analysisCards: prev.analysisCards.map(c => c.id === cardId ? {...c, hideOthers: hide} : c) }));
    const handleToggleLegendLabel = (cardId, label) => {
        setAppState(prev => ({ ...prev, analysisCards: prev.analysisCards.map(c => {
                if (c.id === cardId) {
                    const currentHidden = c.hiddenLabels || [];
                    const newHidden = currentHidden.includes(label) ? currentHidden.filter(l => l !== label) : [...currentHidden, label];
                    return { ...c, hiddenLabels: newHidden };
                }
                return c;
            })
        }));
    };

    const handleLoadReport = async (id) => {
        addProgress(`Loading report ${id}...`);
        const report = await getReport(id);
        if (report && isMounted.current) {
            vectorStore.clear();
            setAppState({ ...report.appState, currentView: 'analysis_dashboard' });
            if (report.appState.vectorStoreDocuments) {
                vectorStore.rehydrate(report.appState.vectorStoreDocuments);
                addProgress('AI long-term memory restored from report.');
            }
            setIsHistoryPanelOpen(false);
            addProgress(`Report "${report.filename}" loaded successfully.`);
        } else addProgress(`Failed to load report ${id}.`, 'error');
    };

    const handleDeleteReport = async (id) => { await deleteReport(id); await loadReportsList(); };
    
    const handleShowCardFromChat = (cardId) => {
        const element = document.getElementById(cardId);
        if (element) {
            element.scrollIntoView({ behavior: 'smooth', block: 'center' });
            element.classList.add('ring-4', 'ring-blue-500', 'transition-all', 'duration-500');
            setTimeout(() => element.classList.remove('ring-4', 'ring-blue-500'), 2500);
        } else addProgress(`Could not find card ID ${cardId} to show.`, 'error');
    };

    const handleNewSession = async () => {
        addProgress('Starting new session...');
        if (appState.csvData && appState.csvData.data.length > 0) {
            const existingSession = await getReport(CURRENT_SESSION_KEY);
            if (existingSession) await saveReport({ ...existingSession, id: `report-${existingSession.createdAt.getTime()}`, updatedAt: new Date() });
        }
        vectorStore.clear();
        await deleteReport(CURRENT_SESSION_KEY);
        setAppState(initialState);
        await loadReportsList();
        addProgress('New session started. Please upload a file.');
    };

    const { isBusy, progressMessages, csvData, analysisCards, chatHistory, finalSummary, currentView } = appState;

    const renderMainContent = () => {
        if (currentView === 'file_upload' || !csvData) {
            return <div className="flex-grow min-h-0"><FileUpload onFileUpload={handleFileUpload} isBusy={isBusy} progressMessages={progressMessages} fileName={csvData?.fileName || null} isApiKeySet={isApiKeySet}/></div>;
        }
        return (
            <div className="flex-grow min-h-0 overflow-y-auto">
                <AnalysisPanel cards={analysisCards} finalSummary={finalSummary} onChartTypeChange={handleChartTypeChange} onToggleDataVisibility={handleToggleDataVisibility} onTopNChange={handleTopNChange} onHideOthersChange={handleHideOthersChange} onToggleLegendLabel={handleToggleLegendLabel} />
                {appState.dataPreparationPlan && appState.dataPreparationPlan.jsFunctionBody && appState.initialDataSample && (
                    <div className="mt-8"><DataPrepDebugPanel plan={appState.dataPreparationPlan} originalSample={appState.initialDataSample} transformedSample={csvData.data.slice(0, 20)} isVisible={isDataPrepDebugVisible} onToggleVisibility={() => setIsDataPrepDebugVisible(prev => !prev)} /></div>
                )}
                <div className="mt-8"><SpreadsheetPanel csvData={csvData} isVisible={isSpreadsheetVisible} onToggleVisibility={() => setIsSpreadsheetVisible(prev => !prev)} /></div>
            </div>
        );
    }

    return (
        <div className="flex flex-col md:flex-row h-screen bg-slate-50 text-slate-800 font-sans">
            <SettingsModal isOpen={isSettingsModalOpen} onClose={() => setIsSettingsModalOpen(false)} onSave={handleSaveSettings} currentSettings={settings} />
            <HistoryPanel isOpen={isHistoryPanelOpen} onClose={() => setIsHistoryPanelOpen(false)} reports={reportsList} onLoadReport={handleLoadReport} onDeleteReport={handleDeleteReport} />
            <MemoryPanel isOpen={isMemoryPanelOpen} onClose={() => setIsMemoryPanelOpen(false)} />
            <main className="flex-1 overflow-hidden p-4 md:p-6 lg:p-8 flex flex-col">
                <header className="mb-6 flex justify-between items-center flex-shrink-0">
                    <div><h1 className="text-3xl font-bold text-slate-900">CSV Data Analysis Agent</h1></div>
                     <div className="flex items-center space-x-2">
                         <button onClick={handleNewSession} className="flex items-center space-x-2 px-3 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors" title="Start a new analysis session"><NewIcon /> <span className="hidden sm:inline">New</span></button>
                        <button onClick={() => {loadReportsList(); setIsHistoryPanelOpen(true);}} className="flex items-center space-x-2 px-3 py-2 bg-slate-200 text-slate-700 rounded-md hover:bg-slate-300 transition-colors" title="View analysis history"><HistoryIcon /> <span className="hidden sm:inline">History</span></button>
                        {!isAsideVisible && <button onClick={() => setIsAsideVisible(true)} className="p-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors" aria-label="Show Assistant Panel" title="Show Assistant Panel"><ShowAssistantIcon /></button>}
                    </div>
                </header>
                {renderMainContent()}
            </main>
            {isAsideVisible && (
                <>
                    <div onMouseDown={handleAsideMouseDown} className="hidden md:block w-1.5 cursor-col-resize bg-slate-300 hover:bg-brand-secondary transition-colors duration-200"/>
                    <aside className="w-full md:w-auto bg-white flex flex-col h-full border-l border-slate-200" style={{ width: asideWidth }}>
                        <ChatPanel progressMessages={progressMessages} chatHistory={chatHistory} isBusy={isBusy} onSendMessage={handleChatMessage} isApiKeySet={isApiKeySet} onToggleVisibility={() => setIsAsideVisible(false)} onOpenSettings={() => setIsSettingsModalOpen(true)} onOpenMemory={() => setIsMemoryPanelOpen(true)} onShowCard={handleShowCardFromChat} currentView={currentView} />
                    </aside>
                </>
            )}
        </div>
    );
};

// =================================================================================
// from index.tsx (entry point)
// =================================================================================
const rootElement = document.getElementById('root');
if (!rootElement) {
  throw new Error("Could not find root element to mount to");
}
const root = ReactDOM.createRoot(rootElement);
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

// --- END OF INLINED CODE ---
    </script>
  </body>
</html>
